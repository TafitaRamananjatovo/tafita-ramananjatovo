"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/marked";
exports.ids = ["vendor-chunks/marked"];
exports.modules = {

/***/ "(action-browser)/./node_modules/marked/lib/marked.cjs":
/*!********************************************!*\
  !*** ./node_modules/marked/lib/marked.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * marked v7.0.4 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ \n/**\n * Gets the original marked default options.\n */ function _getDefaults() {\n    return {\n        async: false,\n        baseUrl: null,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        headerIds: false,\n        headerPrefix: \"\",\n        highlight: null,\n        hooks: null,\n        langPrefix: \"language-\",\n        mangle: false,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n    };\n}\nexports.defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    exports.defaults = newDefaults;\n}\n/**\n * Helpers\n */ const escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, \"g\");\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\nconst escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nconst getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\nfunction unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n)=>{\n        n = n.toLowerCase();\n        if (n === \"colon\") return \":\";\n        if (n.charAt(0) === \"#\") {\n            return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n        }\n        return \"\";\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n    regex = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    const obj = {\n        replace: (name, val)=>{\n            val = typeof val === \"object\" && \"source\" in val ? val.source : val;\n            val = val.replace(caret, \"$1\");\n            regex = regex.replace(name, val);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(regex, opt);\n        }\n    };\n    return obj;\n}\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\nfunction cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n        let prot;\n        try {\n            prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, \"\").toLowerCase();\n        } catch (e) {\n            return null;\n        }\n        if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n            return null;\n        }\n    }\n    if (base && !originIndependentUrl.test(href)) {\n        href = resolveUrl(base, href);\n    }\n    try {\n        href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\nfunction resolveUrl(base, href) {\n    if (!baseUrls[\" \" + base]) {\n        // we can ignore everything in base after the last slash of its path component,\n        // but we might need to add _that_\n        // https://tools.ietf.org/html/rfc3986#section-3\n        if (justDomain.test(base)) {\n            baseUrls[\" \" + base] = base + \"/\";\n        } else {\n            baseUrls[\" \" + base] = rtrim(base, \"/\", true);\n        }\n    }\n    base = baseUrls[\" \" + base];\n    const relativeBase = base.indexOf(\":\") === -1;\n    if (href.substring(0, 2) === \"//\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(protocol, \"$1\") + href;\n    } else if (href.charAt(0) === \"/\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(domain, \"$1\") + href;\n    } else {\n        return base + href;\n    }\n}\nconst noopTest = {\n    exec: ()=>null\n};\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n        let escaped = false;\n        let curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while(cells.length < count)cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for(let i = 0; i < str.length; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction checkDeprecations(opt, callback) {\n    if (!opt || opt.silent) {\n        return;\n    }\n    if (callback) {\n        console.warn(\"marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async\");\n    }\n    if (opt.sanitize || opt.sanitizer) {\n        console.warn(\"marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options\");\n    }\n    if (opt.highlight || opt.langPrefix !== \"language-\") {\n        console.warn(\"marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight.\");\n    }\n    if (opt.mangle) {\n        console.warn(\"marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`.\");\n    }\n    if (opt.baseUrl) {\n        console.warn(\"marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url.\");\n    }\n    if (opt.smartypants) {\n        console.warn(\"marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants.\");\n    }\n    if (opt.xhtml) {\n        console.warn(\"marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml.\");\n    }\n    if (opt.headerIds || opt.headerPrefix) {\n        console.warn(\"marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`.\");\n    }\n}\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        const token = {\n            type: \"link\",\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw,\n        href,\n        title,\n        text: escape(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ class _Tokenizer {\n    constructor(options){\n        this.options = options || exports.defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ *>[ \\t]?/gm, \"\");\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: \"blockquote\",\n                raw: cap[0],\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = \"\";\n            let itemContents = \"\";\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while(src){\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                let nextLine = src.split(\"\\n\", 1)[0];\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimLeft();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                let blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        const rawLine = src.split(\"\\n\", 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimRight();\n            list.items[list.items.length - 1].text = itemContents.trimRight();\n            list.raw = list.raw.trimRight();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(let i = 0; i < list.items.length; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(let i = 0; i < list.items.length; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: !this.options.sanitizer && (cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\"),\n                text: cap[0]\n            };\n            if (this.options.sanitize) {\n                const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n                const paragraph = token;\n                paragraph.type = \"paragraph\";\n                paragraph.text = text;\n                paragraph.tokens = this.lexer.inline(text);\n            }\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline._escapes, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (cap) {\n            const item = {\n                type: \"table\",\n                raw: cap[0],\n                header: splitCells(cap[1]).map((c)=>{\n                    return {\n                        text: c,\n                        tokens: []\n                    };\n                }),\n                align: cap[2].replace(/^ *|\\| *$/g, \"\").split(/ *\\| */),\n                rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : []\n            };\n            if (item.header.length === item.align.length) {\n                let l = item.align.length;\n                let i, j, k, row;\n                for(i = 0; i < l; i++){\n                    const align = item.align[i];\n                    if (align) {\n                        if (/^ *-+: *$/.test(align)) {\n                            item.align[i] = \"right\";\n                        } else if (/^ *:-+: *$/.test(align)) {\n                            item.align[i] = \"center\";\n                        } else if (/^ *:-+ *$/.test(align)) {\n                            item.align[i] = \"left\";\n                        } else {\n                            item.align[i] = null;\n                        }\n                    }\n                }\n                l = item.rows.length;\n                for(i = 0; i < l; i++){\n                    item.rows[i] = splitCells(item.rows[i], item.header.length).map((c)=>{\n                        return {\n                            text: c,\n                            tokens: []\n                        };\n                    });\n                }\n                // parse child tokens inside headers and cells\n                // header child tokens\n                l = item.header.length;\n                for(j = 0; j < l; j++){\n                    item.header[j].tokens = this.lexer.inline(item.header[j].text);\n                }\n                // cell child tokens\n                l = item.rows.length;\n                for(j = 0; j < l; j++){\n                    row = item.rows[j];\n                    for(k = 0; k < row.length; k++){\n                        row[k].tokens = this.lexer.inline(row[k].text);\n                    }\n                }\n                return item;\n            }\n        }\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape(cap[1])\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: this.options.sanitize ? \"text\" : \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!/>$/.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline._escapes, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline._escapes, \"$1\") : title\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            let link = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            link = links[link.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = \"\") {\n        let match = this.rules.inline.emStrong.lDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [\n                ...match[0]\n            ].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = [\n                    ...rDelim\n                ].length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                const raw = [\n                    ...src\n                ].slice(0, lLength + match.index + rLength + 1).join(\"\");\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, \" \");\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src, mangle) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n                href = \"mailto:\" + text;\n            } else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src, mangle) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n                }while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src, smartypants) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n            } else {\n                text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n            }\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n}\n/**\n * Block-Level Grammar\n */ // Not all rules are defined in the object literal\n// @ts-expect-error\nconst block = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n    html: \"^ {0,3}(?:\" // optional indentation\n     + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n     + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n     + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n     + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n     + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n     + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (6)\n     + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) open tag\n     + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) closing tag\n     + \")\",\n    def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^((?:(?!^bull ).|\\n(?!\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n};\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def).replace(\"label\", block._label).replace(\"title\", block._title).getRegex();\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */).replace(\"bull\", block.bullet).getRegex();\nblock.list = edit(block.list).replace(/bull/g, block.bullet).replace(\"hr\", \"\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))\").replace(\"def\", \"\\\\n+(?=\" + block.def.source + \")\").getRegex();\nblock._tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr\" + \"|track|ul\";\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, \"i\").replace(\"comment\", block._comment).replace(\"tag\", block._tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nblock.lheading = edit(block.lheading).replace(/bull/g, block.bullet) // lists can interrupt\n.getRegex();\nblock.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nblock.blockquote = edit(block.blockquote).replace(\"paragraph\", block.paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ block.normal = {\n    ...block\n};\n/**\n * GFM Block Grammar\n */ block.gfm = {\n    ...block.normal,\n    table: \"^ *([^\\\\n ].*\\\\|.*)\\\\n\" // Header\n     + \" {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?\" // Align\n     + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\" // Cells\n};\nblock.gfm.table = edit(block.gfm.table).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nblock.gfm.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"table\", block.gfm.table) // interrupt paragraphs with table\n.replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ block.pedantic = {\n    ...block.normal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", block._comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(block.normal._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", block.lheading).replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").getRegex()\n};\n/**\n * Inline-Level Grammar\n */ // Not all rules are defined in the object literal\n// @ts-expect-error\nconst inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: \"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n     + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n     + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n     + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n     + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\",\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n    nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n    reflinkSearch: \"reflink|nolink(?!\\\\()\",\n    emStrong: {\n        lDelim: /^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/,\n        //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n        //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a\n        rDelimAst: /^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])/,\n        rDelimUnd: /^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/ // ^- Not allowed for _\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^((?![*_])[\\spunctuation])/\n};\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\ninline._punctuation = \"\\\\p{P}$+<=>`^|~\";\ninline.punctuation = edit(inline.punctuation, \"u\").replace(/punctuation/g, inline._punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\ninline.anyPunctuation = /\\\\[punct]/g;\ninline._escapes = /\\\\([punct])/g;\ninline._comment = edit(block._comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim, \"u\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline.anyPunctuation = edit(inline.anyPunctuation, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline._escapes = edit(inline._escapes, \"gu\").replace(/punct/g, inline._punctuation).getRegex();\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink).replace(\"scheme\", inline._scheme).replace(\"email\", inline._email).getRegex();\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\ninline.tag = edit(inline.tag).replace(\"comment\", inline._comment).replace(\"attribute\", inline._attribute).getRegex();\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\ninline.link = edit(inline.link).replace(\"label\", inline._label).replace(\"href\", inline._href).replace(\"title\", inline._title).getRegex();\ninline.reflink = edit(inline.reflink).replace(\"label\", inline._label).replace(\"ref\", block._label).getRegex();\ninline.nolink = edit(inline.nolink).replace(\"ref\", block._label).getRegex();\ninline.reflinkSearch = edit(inline.reflinkSearch, \"g\").replace(\"reflink\", inline.reflink).replace(\"nolink\", inline.nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ inline.normal = {\n    ...inline\n};\n/**\n * Pedantic Inline Grammar\n */ inline.pedantic = {\n    ...inline.normal,\n    strong: {\n        start: /^__|\\*\\*/,\n        middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n        endAst: /\\*\\*(?!\\*)/g,\n        endUnd: /__(?!_)/g\n    },\n    em: {\n        start: /^_|\\*/,\n        middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n        endAst: /\\*(?!\\*)/g,\n        endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", inline._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", inline._label).getRegex()\n};\n/**\n * GFM Inline Grammar\n */ inline.gfm = {\n    ...inline.normal,\n    escape: edit(inline.escape).replace(\"])\", \"~|])\").getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\ninline.gfm.url = edit(inline.gfm.url, \"i\").replace(\"email\", inline.gfm._extended_email).getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */ inline.breaks = {\n    ...inline.gfm,\n    br: edit(inline.br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inline.gfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\n/**\n * smartypants text replacement\n */ function smartypants(text) {\n    return text// em-dashes\n    .replace(/---/g, \"—\")// en-dashes\n    .replace(/--/g, \"–\")// opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1‘\")// closing singles & apostrophes\n    .replace(/'/g, \"’\")// opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1“\")// closing doubles\n    .replace(/\"/g, \"”\")// ellipses\n    .replace(/\\.{3}/g, \"…\");\n}\n/**\n * mangle email addresses\n */ function mangle(text) {\n    let out = \"\";\n    for(let i = 0; i < text.length; i++){\n        const ch = Math.random() > 0.5 ? \"x\" + text.charCodeAt(i).toString(16) : text.charCodeAt(i).toString();\n        out += \"&#\" + ch + \";\";\n    }\n    return out;\n}\n/**\n * Block Lexer\n */ class _Lexer {\n    constructor(options){\n        // TokenList cannot be created in one go\n        // @ts-expect-error\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || exports.defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */ static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */ static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */ lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        let next;\n        while(next = this.inlineQueue.shift()){\n            this.inlineTokens(next.src, next.tokens);\n        }\n        return this.tokens;\n    }\n    blockTokens(src, tokens = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs)=>{\n                return leading + \"    \".repeat(tabs.length);\n            });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n        while(src){\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */ inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src, mangle)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n/**\n * Renderer\n */ class _Renderer {\n    constructor(options){\n        this.options = options || exports.defaults;\n    }\n    code(code, infostring, escaped) {\n        const lang = (infostring || \"\").match(/^\\S*/)?.[0];\n        if (this.options.highlight) {\n            const out = this.options.highlight(code, lang);\n            if (out != null && out !== code) {\n                escaped = true;\n                code = out;\n            }\n        }\n        code = code.replace(/\\n$/, \"\") + \"\\n\";\n        if (!lang) {\n            return \"<pre><code>\" + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"' + this.options.langPrefix + escape(lang) + '\">' + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n    }\n    blockquote(quote) {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n    html(html, block) {\n        return html;\n    }\n    heading(text, level, raw, slugger) {\n        if (this.options.headerIds) {\n            const id = this.options.headerPrefix + slugger.slug(raw);\n            return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n        }\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n    hr() {\n        return this.options.xhtml ? \"<hr/>\\n\" : \"<hr>\\n\";\n    }\n    list(body, ordered, start) {\n        const type = ordered ? \"ol\" : \"ul\";\n        const startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    listitem(text, task, checked) {\n        return `<li>${text}</li>\\n`;\n    }\n    checkbox(checked) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? \" /\" : \"\") + \"> \";\n    }\n    paragraph(text) {\n        return `<p>${text}</p>\\n`;\n    }\n    table(header, body) {\n        if (body) body = `<tbody>${body}</tbody>`;\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    tablerow(content) {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n    tablecell(content, flags) {\n        const type = flags.header ? \"th\" : \"td\";\n        const tag = flags.align ? `<${type} align=\"${flags.align}\">` : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */ strong(text) {\n        return `<strong>${text}</strong>`;\n    }\n    em(text) {\n        return `<em>${text}</em>`;\n    }\n    codespan(text) {\n        return `<code>${text}</code>`;\n    }\n    br() {\n        return this.options.xhtml ? \"<br/>\" : \"<br>\";\n    }\n    del(text) {\n        return `<del>${text}</del>`;\n    }\n    link(href, title, text) {\n        const cleanHref = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    image(href, title, text) {\n        const cleanHref = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += this.options.xhtml ? \"/>\" : \">\";\n        return out;\n    }\n    text(text) {\n        return text;\n    }\n}\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ class _TextRenderer {\n    // no need for block level renderers\n    strong(text) {\n        return text;\n    }\n    em(text) {\n        return text;\n    }\n    codespan(text) {\n        return text;\n    }\n    del(text) {\n        return text;\n    }\n    html(text) {\n        return text;\n    }\n    text(text) {\n        return text;\n    }\n    link(href, title, text) {\n        return \"\" + text;\n    }\n    image(href, title, text) {\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n}\n/**\n * Slugger generates header id\n */ class _Slugger {\n    constructor(){\n        this.seen = {};\n    }\n    serialize(value) {\n        return value.toLowerCase().trim()// remove html tags\n        .replace(/<[!\\/a-z].*?>/ig, \"\")// remove unwanted chars\n        .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, \"\").replace(/\\s/g, \"-\");\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */ getNextSafeSlug(originalSlug, isDryRun) {\n        let slug = originalSlug;\n        let occurenceAccumulator = 0;\n        if (this.seen.hasOwnProperty(slug)) {\n            occurenceAccumulator = this.seen[originalSlug];\n            do {\n                occurenceAccumulator++;\n                slug = originalSlug + \"-\" + occurenceAccumulator;\n            }while (this.seen.hasOwnProperty(slug));\n        }\n        if (!isDryRun) {\n            this.seen[originalSlug] = occurenceAccumulator;\n            this.seen[slug] = 0;\n        }\n        return slug;\n    }\n    /**\n     * Convert string to unique id\n     */ slug(value, options = {}) {\n        const slug = this.serialize(value);\n        return this.getNextSafeSlug(slug, options.dryrun);\n    }\n}\n/**\n * Parsing & Compiling\n */ class _Parser {\n    constructor(options){\n        this.options = options || exports.defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n        this.slugger = new _Slugger();\n    }\n    /**\n     * Static Parse Method\n     */ static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */ static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */ parse(tokens, top = true) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const genericToken = token;\n                const ret = this.options.extensions.renderers[genericToken.type].call({\n                    parser: this\n                }, genericToken);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(genericToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"space\":\n                    {\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        const headingToken = token;\n                        out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)), this.slugger);\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        const codeToken = token;\n                        out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        let header = \"\";\n                        // header\n                        let cell = \"\";\n                        for(let j = 0; j < tableToken.header.length; j++){\n                            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), {\n                                header: true,\n                                align: tableToken.align[j]\n                            });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        let body = \"\";\n                        for(let j = 0; j < tableToken.rows.length; j++){\n                            const row = tableToken.rows[j];\n                            cell = \"\";\n                            for(let k = 0; k < row.length; k++){\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: tableToken.align[k]\n                                });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        const blockquoteToken = token;\n                        const body = this.parse(blockquoteToken.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        const ordered = listToken.ordered;\n                        const start = listToken.start;\n                        const loose = listToken.loose;\n                        let body = \"\";\n                        for(let j = 0; j < listToken.items.length; j++){\n                            const item = listToken.items[j];\n                            const checked = item.checked;\n                            const task = item.task;\n                            let itemBody = \"\";\n                            if (item.task) {\n                                const checkbox = this.renderer.checkbox(!!checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                                            item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        }\n                                    } else {\n                                        item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox\n                                        });\n                                    }\n                                } else {\n                                    itemBody += checkbox;\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, !!checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        const htmlToken = token;\n                        out += this.renderer.html(htmlToken.text, htmlToken.block);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        const paragraphToken = token;\n                        out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        let textToken = token;\n                        let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                        while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                            textToken = tokens[++i];\n                            body += \"\\n\" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */ parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"escape\":\n                    {\n                        const escapeToken = token;\n                        out += renderer.text(escapeToken.text);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        const tagToken = token;\n                        out += renderer.html(tagToken.text);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        const linkToken = token;\n                        out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                        break;\n                    }\n                case \"image\":\n                    {\n                        const imageToken = token;\n                        out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        const strongToken = token;\n                        out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                        break;\n                    }\n                case \"em\":\n                    {\n                        const emToken = token;\n                        out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        const codespanToken = token;\n                        out += renderer.codespan(codespanToken.text);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br();\n                        break;\n                    }\n                case \"del\":\n                    {\n                        const delToken = token;\n                        out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                        break;\n                    }\n                case \"text\":\n                    {\n                        const textToken = token;\n                        out += renderer.text(textToken.text);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n}\nclass _Hooks {\n    constructor(options){\n        this.options = options || exports.defaults;\n    }\n    static{\n        this.passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\"\n        ]);\n    }\n    /**\n     * Process markdown before marked\n     */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */ postprocess(html) {\n        return html;\n    }\n}\nclass Marked {\n    constructor(...args){\n        this.defaults = _getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        this.parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        this.Parser = _Parser;\n        this.parser = _Parser.parse;\n        this.Renderer = _Renderer;\n        this.TextRenderer = _TextRenderer;\n        this.Lexer = _Lexer;\n        this.lexer = _Lexer.lex;\n        this.Tokenizer = _Tokenizer;\n        this.Slugger = _Slugger;\n        this.Hooks = _Hooks;\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */ walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        for (const cell of tableToken.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                values = values.concat(this.walkTokens(genericToken[childTokens], callback));\n                            });\n                        } else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            // copy options to new object\n            const opts = {\n                ...pack\n            };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (\"renderer\" in ext) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (\"tokenizer\" in ext) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (\"childTokens\" in ext && ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    const rendererFunc = pack.renderer[prop];\n                    const rendererKey = prop;\n                    const prevRenderer = renderer[rendererKey];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererKey] = (...args)=>{\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || \"\";\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    const tokenizerFunc = pack.tokenizer[prop];\n                    const tokenizerKey = prop;\n                    const prevTokenizer = tokenizer[tokenizerKey];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    tokenizer[tokenizerKey] = (...args)=>{\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for(const prop in pack.hooks){\n                    const hooksFunc = pack.hooks[prop];\n                    const hooksKey = prop;\n                    const prevHook = hooks[hooksKey];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        hooks[hooksKey] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        hooks[hooksKey] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    #parseMarkdown(lexer, parser) {\n        return (src, optOrCallback, callback)=>{\n            if (typeof optOrCallback === \"function\") {\n                callback = optOrCallback;\n                optOrCallback = null;\n            }\n            const origOpt = {\n                ...optOrCallback\n            };\n            const opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn(\"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.\");\n                }\n                opt.async = true;\n            }\n            const throwError = this.#onError(!!opt.silent, !!opt.async, callback);\n            // throw error in case of non string input\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            checkDeprecations(opt, callback);\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (callback) {\n                const resultCallback = callback;\n                const highlight = opt.highlight;\n                let tokens;\n                try {\n                    if (opt.hooks) {\n                        src = opt.hooks.preprocess(src);\n                    }\n                    tokens = lexer(src, opt);\n                } catch (e) {\n                    return throwError(e);\n                }\n                const done = (err)=>{\n                    let out;\n                    if (!err) {\n                        try {\n                            if (opt.walkTokens) {\n                                this.walkTokens(tokens, opt.walkTokens);\n                            }\n                            out = parser(tokens, opt);\n                            if (opt.hooks) {\n                                out = opt.hooks.postprocess(out);\n                            }\n                        } catch (e) {\n                            err = e;\n                        }\n                    }\n                    opt.highlight = highlight;\n                    return err ? throwError(err) : resultCallback(null, out);\n                };\n                if (!highlight || highlight.length < 3) {\n                    return done();\n                }\n                delete opt.highlight;\n                if (!tokens.length) return done();\n                let pending = 0;\n                this.walkTokens(tokens, (token)=>{\n                    if (token.type === \"code\") {\n                        pending++;\n                        setTimeout(()=>{\n                            highlight(token.text, token.lang, (err, code)=>{\n                                if (err) {\n                                    return done(err);\n                                }\n                                if (code != null && code !== token.text) {\n                                    token.text = code;\n                                    token.escaped = true;\n                                }\n                                pending--;\n                                if (pending === 0) {\n                                    done();\n                                }\n                            });\n                        }, 0);\n                    }\n                });\n                if (pending === 0) {\n                    done();\n                }\n                return;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                const tokens = lexer(src, opt);\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n    }\n    #onError(silent, async, callback) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                if (callback) {\n                    callback(null, msg);\n                    return;\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            if (callback) {\n                callback(e);\n                return;\n            }\n            throw e;\n        };\n    }\n}\nconst markedInstance = new Marked();\nfunction marked(src, opt, callback) {\n    return markedInstance.parse(src, opt, callback);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */ marked.options = marked.setOptions = function(options) {\n    markedInstance.setOptions(options);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Gets the original marked default options.\n */ marked.getDefaults = _getDefaults;\nmarked.defaults = exports.defaults;\n/**\n * Use Extension\n */ marked.use = function(...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */ marked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */ marked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Slugger = _Slugger;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\nexports.Hooks = _Hooks;\nexports.Lexer = _Lexer;\nexports.Marked = Marked;\nexports.Parser = _Parser;\nexports.Renderer = _Renderer;\nexports.Slugger = _Slugger;\nexports.TextRenderer = _TextRenderer;\nexports.Tokenizer = _Tokenizer;\nexports.getDefaults = _getDefaults;\nexports.lexer = lexer;\nexports.marked = marked;\nexports.options = options;\nexports.parse = parse;\nexports.parseInline = parseInline;\nexports.parser = parser;\nexports.setOptions = setOptions;\nexports.use = use;\nexports.walkTokens = walkTokens; //# sourceMappingURL=marked.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5janMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVEOzs7Q0FHQyxHQUVEO0FBRUE7O0NBRUMsR0FDRCxTQUFTQTtJQUNMLE9BQU87UUFDSEMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLFFBQVE7UUFDUkMsWUFBWTtRQUNaQyxLQUFLO1FBQ0xDLFdBQVc7UUFDWEMsY0FBYztRQUNkQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsWUFBWTtRQUNaQyxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFdBQVc7UUFDWEMsUUFBUTtRQUNSQyxhQUFhO1FBQ2JDLFdBQVc7UUFDWEMsWUFBWTtRQUNaQyxPQUFPO0lBQ1g7QUFDSjtBQUNBQyxnQkFBZ0IsR0FBR3JCO0FBQ25CLFNBQVN1QixlQUFlQyxXQUFXO0lBQy9CSCxnQkFBZ0IsR0FBR0c7QUFDdkI7QUFFQTs7Q0FFQyxHQUNELE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsZ0JBQWdCLElBQUlDLE9BQU9GLFdBQVdHLE1BQU0sRUFBRTtBQUNwRCxNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsd0JBQXdCLElBQUlILE9BQU9FLG1CQUFtQkQsTUFBTSxFQUFFO0FBQ3BFLE1BQU1HLHFCQUFxQjtJQUN2QixLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztBQUNUO0FBQ0EsTUFBTUMsdUJBQXVCLENBQUNDLEtBQU9GLGtCQUFrQixDQUFDRSxHQUFHO0FBQzNELFNBQVNDLE9BQU9DLElBQUksRUFBRUMsTUFBTTtJQUN4QixJQUFJQSxRQUFRO1FBQ1IsSUFBSVgsV0FBV1ksSUFBSSxDQUFDRixPQUFPO1lBQ3ZCLE9BQU9BLEtBQUtHLE9BQU8sQ0FBQ1osZUFBZU07UUFDdkM7SUFDSixPQUNLO1FBQ0QsSUFBSUgsbUJBQW1CUSxJQUFJLENBQUNGLE9BQU87WUFDL0IsT0FBT0EsS0FB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cUIsYUFBYSxHQUFHMEY7QUFDaEIxRixjQUFjLEdBQUd3WDtBQUNqQnhYLGVBQWUsR0FBRzZHO0FBQ2xCN0csYUFBYSxHQUFHcVM7QUFDaEJyUyxtQkFBbUIsR0FBR3VTO0FBQ3RCdlMsY0FBYyxHQUFHc1M7QUFDakJ0UyxrQkFBa0IsR0FBR3NVO0FBQ3JCdFUsV0FBVyxHQUFHK1U7QUFDZC9VLGtCQUFrQixHQUFHRixZQUNyQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuY2pzPzY5ODQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtYXJrZWQgdjcuMC40IC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIzLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIG9yaWdpbmFsIG1hcmtlZCBkZWZhdWx0IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIF9nZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgIGJhc2VVcmw6IG51bGwsXG4gICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgICAgIGdmbTogdHJ1ZSxcbiAgICAgICAgaGVhZGVySWRzOiBmYWxzZSxcbiAgICAgICAgaGVhZGVyUHJlZml4OiAnJyxcbiAgICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgICBob29rczogbnVsbCxcbiAgICAgICAgbGFuZ1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgICAgIG1hbmdsZTogZmFsc2UsXG4gICAgICAgIHBlZGFudGljOiBmYWxzZSxcbiAgICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICAgICAgc2FuaXRpemVyOiBudWxsLFxuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgICAgICBzbWFydHlwYW50czogZmFsc2UsXG4gICAgICAgIHRva2VuaXplcjogbnVsbCxcbiAgICAgICAgd2Fsa1Rva2VuczogbnVsbCxcbiAgICAgICAgeGh0bWw6IGZhbHNlXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gICAgZXhwb3J0cy5kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xufVxuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuY29uc3QgZXNjYXBlVGVzdCA9IC9bJjw+XCInXS87XG5jb25zdCBlc2NhcGVSZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0LnNvdXJjZSwgJ2cnKTtcbmNvbnN0IGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEoI1xcZHsxLDd9fCNbWHhdW2EtZkEtRjAtOV17MSw2fXxcXHcrKTspLztcbmNvbnN0IGVzY2FwZVJlcGxhY2VOb0VuY29kZSA9IG5ldyBSZWdFeHAoZXNjYXBlVGVzdE5vRW5jb2RlLnNvdXJjZSwgJ2cnKTtcbmNvbnN0IGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5Oydcbn07XG5jb25zdCBnZXRFc2NhcGVSZXBsYWNlbWVudCA9IChjaCkgPT4gZXNjYXBlUmVwbGFjZW1lbnRzW2NoXTtcbmZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgICBpZiAoZW5jb2RlKSB7XG4gICAgICAgIGlmIChlc2NhcGVUZXN0LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZXNjYXBlVGVzdE5vRW5jb2RlLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG59XG5jb25zdCB1bmVzY2FwZVRlc3QgPSAvJigjKD86XFxkKyl8KD86I3hbMC05QS1GYS1mXSspfCg/OlxcdyspKTs/L2lnO1xuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuICAgIC8vIGV4cGxpY2l0bHkgbWF0Y2ggZGVjaW1hbCwgaGV4LCBhbmQgbmFtZWQgSFRNTCBlbnRpdGllc1xuICAgIHJldHVybiBodG1sLnJlcGxhY2UodW5lc2NhcGVUZXN0LCAoXywgbikgPT4ge1xuICAgICAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobiA9PT0gJ2NvbG9uJylcbiAgICAgICAgICAgIHJldHVybiAnOic7XG4gICAgICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICAgICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKVxuICAgICAgICAgICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbn1cbmNvbnN0IGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcbmZ1bmN0aW9uIGVkaXQocmVnZXgsIG9wdCkge1xuICAgIHJlZ2V4ID0gdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyA/IHJlZ2V4IDogcmVnZXguc291cmNlO1xuICAgIG9wdCA9IG9wdCB8fCAnJztcbiAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIHJlcGxhY2U6IChuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICdzb3VyY2UnIGluIHZhbCA/IHZhbC5zb3VyY2UgOiB2YWw7XG4gICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICAgICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJlZ2V4OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IG5vbldvcmRBbmRDb2xvblRlc3QgPSAvW15cXHc6XS9nO1xuY29uc3Qgb3JpZ2luSW5kZXBlbmRlbnRVcmwgPSAvXiR8XlthLXpdW2EtejAtOSsuLV0qOnxeWz8jXS9pO1xuZnVuY3Rpb24gY2xlYW5Vcmwoc2FuaXRpemUsIGJhc2UsIGhyZWYpIHtcbiAgICBpZiAoc2FuaXRpemUpIHtcbiAgICAgICAgbGV0IHByb3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm90ID0gZGVjb2RlVVJJQ29tcG9uZW50KHVuZXNjYXBlKGhyZWYpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5vbldvcmRBbmRDb2xvblRlc3QsICcnKVxuICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFzZSAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgICAgICBocmVmID0gcmVzb2x2ZVVybChiYXNlLCBocmVmKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaHJlZiA9IGVuY29kZVVSSShocmVmKS5yZXBsYWNlKC8lMjUvZywgJyUnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBocmVmO1xufVxuY29uc3QgYmFzZVVybHMgPSB7fTtcbmNvbnN0IGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuY29uc3QgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG5jb25zdCBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2UsIGhyZWYpIHtcbiAgICBpZiAoIWJhc2VVcmxzWycgJyArIGJhc2VdKSB7XG4gICAgICAgIC8vIHdlIGNhbiBpZ25vcmUgZXZlcnl0aGluZyBpbiBiYXNlIGFmdGVyIHRoZSBsYXN0IHNsYXNoIG9mIGl0cyBwYXRoIGNvbXBvbmVudCxcbiAgICAgICAgLy8gYnV0IHdlIG1pZ2h0IG5lZWQgdG8gYWRkIF90aGF0X1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTNcbiAgICAgICAgaWYgKGp1c3REb21haW4udGVzdChiYXNlKSkge1xuICAgICAgICAgICAgYmFzZVVybHNbJyAnICsgYmFzZV0gPSBiYXNlICsgJy8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVybHNbJyAnICsgYmFzZV0gPSBydHJpbShiYXNlLCAnLycsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhc2UgPSBiYXNlVXJsc1snICcgKyBiYXNlXTtcbiAgICBjb25zdCByZWxhdGl2ZUJhc2UgPSBiYXNlLmluZGV4T2YoJzonKSA9PT0gLTE7XG4gICAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZUJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaHJlZi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaHJlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKGRvbWFpbiwgJyQxJykgKyBocmVmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICAgIH1cbn1cbmNvbnN0IG5vb3BUZXN0ID0geyBleGVjOiAoKSA9PiBudWxsIH07XG5mdW5jdGlvbiBzcGxpdENlbGxzKHRhYmxlUm93LCBjb3VudCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gICAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gICAgY29uc3Qgcm93ID0gdGFibGVSb3cucmVwbGFjZSgvXFx8L2csIChtYXRjaCwgb2Zmc2V0LCBzdHIpID0+IHtcbiAgICAgICAgbGV0IGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGN1cnIgPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlICgtLWN1cnIgPj0gMCAmJiBzdHJbY3Vycl0gPT09ICdcXFxcJylcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgICAgIC8vIG9kZCBudW1iZXIgb2Ygc2xhc2hlcyBtZWFucyB8IGlzIGVzY2FwZWRcbiAgICAgICAgICAgIC8vIHNvIHdlIGxlYXZlIGl0IGFsb25lXG4gICAgICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICAgICAgcmV0dXJuICcgfCc7XG4gICAgICAgIH1cbiAgICB9KSwgY2VsbHMgPSByb3cuc3BsaXQoLyBcXHwvKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gRmlyc3QvbGFzdCBjZWxsIGluIGEgcm93IGNhbm5vdCBiZSBlbXB0eSBpZiBpdCBoYXMgbm8gbGVhZGluZy90cmFpbGluZyBwaXBlXG4gICAgaWYgKCFjZWxsc1swXS50cmltKCkpIHtcbiAgICAgICAgY2VsbHMuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKGNlbGxzLmxlbmd0aCA+IDAgJiYgIWNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdLnRyaW0oKSkge1xuICAgICAgICBjZWxscy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAgIGlmIChjZWxscy5sZW5ndGggPiBjb3VudCkge1xuICAgICAgICAgICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudClcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICAgICAgY2VsbHNbaV0gPSBjZWxsc1tpXS50cmltKCkucmVwbGFjZSgvXFxcXFxcfC9nLCAnfCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG4vKipcbiAqIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gKiAvYyokLyBpcyB2dWxuZXJhYmxlIHRvIFJFRE9TLlxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEBwYXJhbSBjXG4gKiBAcGFyYW0gaW52ZXJ0IFJlbW92ZSBzdWZmaXggb2Ygbm9uLWMgY2hhcnMgaW5zdGVhZC4gRGVmYXVsdCBmYWxzZXkuXG4gKi9cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIGxldCBzdWZmTGVuID0gMDtcbiAgICAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgICAgY29uc3QgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiAhaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGwgLSBzdWZmTGVuKTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IGxldmVsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRpb25zKG9wdCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdCB8fCBvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IGNhbGxiYWNrIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjAuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vbWFya2VkLmpzLm9yZy91c2luZ19wcm8jYXN5bmMnKTtcbiAgICB9XG4gICAgaWYgKG9wdC5zYW5pdGl6ZSB8fCBvcHQuc2FuaXRpemVyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IHNhbml0aXplIGFuZCBzYW5pdGl6ZXIgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuNy4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9tYXJrZWQuanMub3JnLyMvVVNJTkdfQURWQU5DRUQubWQjb3B0aW9ucycpO1xuICAgIH1cbiAgICBpZiAob3B0LmhpZ2hsaWdodCB8fCBvcHQubGFuZ1ByZWZpeCAhPT0gJ2xhbmd1YWdlLScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogaGlnaGxpZ2h0IGFuZCBsYW5nUHJlZml4IHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjAuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gSW5zdGVhZCB1c2UgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2VkLWhpZ2hsaWdodC4nKTtcbiAgICB9XG4gICAgaWYgKG9wdC5tYW5nbGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogbWFuZ2xlIHBhcmFtZXRlciBpcyBlbmFibGVkIGJ5IGRlZmF1bHQsIGJ1dCBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNS4wLjAsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gVG8gY2xlYXIgdGhpcyB3YXJuaW5nLCBpbnN0YWxsIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21hcmtlZC1tYW5nbGUsIG9yIGRpc2FibGUgYnkgc2V0dGluZyBge21hbmdsZTogZmFsc2V9YC4nKTtcbiAgICB9XG4gICAgaWYgKG9wdC5iYXNlVXJsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IGJhc2VVcmwgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjAuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gSW5zdGVhZCB1c2UgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2VkLWJhc2UtdXJsLicpO1xuICAgIH1cbiAgICBpZiAob3B0LnNtYXJ0eXBhbnRzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWFya2VkKCk6IHNtYXJ0eXBhbnRzIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNS4wLjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIEluc3RlYWQgdXNlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21hcmtlZC1zbWFydHlwYW50cy4nKTtcbiAgICB9XG4gICAgaWYgKG9wdC54aHRtbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiB4aHRtbCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMC4wLCBzaG91bGQgbm90IGJlIHVzZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBJbnN0ZWFkIHVzZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tYXJrZWQteGh0bWwuJyk7XG4gICAgfVxuICAgIGlmIChvcHQuaGVhZGVySWRzIHx8IG9wdC5oZWFkZXJQcmVmaXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogaGVhZGVySWRzIGFuZCBoZWFkZXJQcmVmaXggcGFyYW1ldGVycyBlbmFibGVkIGJ5IGRlZmF1bHQsIGJ1dCBhcmUgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMC4wLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFRvIGNsZWFyIHRoaXMgd2FybmluZywgaW5zdGFsbCAgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2VkLWdmbS1oZWFkaW5nLWlkLCBvciBkaXNhYmxlIGJ5IHNldHRpbmcgYHtoZWFkZXJJZHM6IGZhbHNlfWAuJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluaywgcmF3LCBsZXhlcikge1xuICAgIGNvbnN0IGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgY29uc3QgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgfTtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3LFxuICAgICAgICBocmVmLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdGV4dDogZXNjYXBlKHRleHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vKipcbiAqIFRva2VuaXplclxuICovXG5jbGFzcyBfVG9rZW5pemVyIHtcbiAgICBvcHRpb25zO1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIHJ1bGVzIHR5cGVcbiAgICBydWxlcztcbiAgICBsZXhlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZXhwb3J0cy5kZWZhdWx0cztcbiAgICB9XG4gICAgc3BhY2Uoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2submV3bGluZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXAgJiYgY2FwWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgICAgICAgICAgPyBydHJpbSh0ZXh0LCAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgOiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZlbmNlcyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgbGFuZzogY2FwWzJdID8gY2FwWzJdLnRyaW0oKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGNhcFsyXSxcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhlYWRpbmcoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaGVhZGluZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgaWYgKC8jJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBydHJpbSh0ZXh0LCAnIycpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbW9uTWFyayByZXF1aXJlcyBzcGFjZSBiZWZvcmUgdHJhaWxpbmcgI3NcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZSh0ZXh0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBocihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hyJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja3F1b3RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj5bIFxcdF0/L2dtLCAnJyk7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLmxleGVyLnN0YXRlLnRvcDtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnModGV4dCk7XG4gICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpc3Qoc3JjKSB7XG4gICAgICAgIGxldCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgYnVsbCA9IGNhcFsxXS50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgICAgICByYXc6ICcnLFxuICAgICAgICAgICAgICAgIG9yZGVyZWQ6IGlzb3JkZXJlZCxcbiAgICAgICAgICAgICAgICBzdGFydDogaXNvcmRlcmVkID8gK2J1bGwuc2xpY2UoMCwgLTEpIDogJycsXG4gICAgICAgICAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBgXFxcXGR7MSw5fVxcXFwke2J1bGwuc2xpY2UoLTEpfWAgOiBgXFxcXCR7YnVsbH1gO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBuZXh0IGxpc3QgaXRlbVxuICAgICAgICAgICAgY29uc3QgaXRlbVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiggezAsM30ke2J1bGx9KSgoPzpbXFx0IF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgICAgbGV0IHJhdyA9ICcnO1xuICAgICAgICAgICAgbGV0IGl0ZW1Db250ZW50cyA9ICcnO1xuICAgICAgICAgICAgbGV0IGVuZHNXaXRoQmxhbmtMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGJ1bGxldCBwb2ludCBjYW4gc3RhcnQgYSBuZXcgTGlzdCBJdGVtXG4gICAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FwID0gaXRlbVJlZ2V4LmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJ1bGVzLmJsb2NrLmhyLnRlc3Qoc3JjKSkgeyAvLyBFbmQgbGlzdCBpZiBidWxsZXQgd2FzIGFjdHVhbGx5IEhSIChwb3NzaWJseSBtb3ZlIGludG8gaXRlbVJlZ2V4PylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhdyA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gY2FwWzJdLnNwbGl0KCdcXG4nLCAxKVswXS5yZXBsYWNlKC9eXFx0Ky8sICh0KSA9PiAnICcucmVwZWF0KDMgKiB0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0TGluZSA9IHNyYy5zcGxpdCgnXFxuJywgMSlbMF07XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnRyaW1MZWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBjYXBbMl0uc2VhcmNoKC9bXiBdLyk7IC8vIEZpbmQgZmlyc3Qgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50ID4gNCA/IDEgOiBpbmRlbnQ7IC8vIFRyZWF0IGluZGVudGVkIGNvZGUgYmxvY2tzICg+IDQgc3BhY2VzKSBhcyBoYXZpbmcgb25seSAxIGluZGVudFxuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBjYXBbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmxhbmtMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lICYmIC9eICokLy50ZXN0KG5leHRMaW5lKSkgeyAvLyBJdGVtcyBiZWdpbiB3aXRoIGF0IG1vc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmF3ICs9IG5leHRMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcobmV4dExpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFxcdF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoclJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oKD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZW5jZXNCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpcXGBcXGBcXGB8fn5+KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19I2ApO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmb2xsb3dpbmcgbGluZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIExpc3QgSXRlbVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gcmF3TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLWFsaWduIHRvIGZvbGxvdyBjb21tb25tYXJrIG5lc3RpbmcgcnVsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IG5leHRMaW5lLnJlcGxhY2UoL14gezEsNH0oPz0oIHs0fSkqW14gXSkvZywgJyAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIGNvZGUgZmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgaGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0QnVsbGV0UmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgcnVsZSBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhyUmVnZXgudGVzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dExpbmUuc2VhcmNoKC9bXiBdLykgPj0gaW5kZW50IHx8ICFuZXh0TGluZS50cmltKCkpIHsgLy8gRGVkZW50IGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbmV4dExpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJhZ3JhcGggY29udGludWF0aW9uIHVubGVzcyBsYXN0IGxpbmUgd2FzIGEgZGlmZmVyZW50IGJsb2NrIGxldmVsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zZWFyY2goL1teIF0vKSA+PSA0KSB7IC8vIGluZGVudGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkaW5nQmVnaW5SZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBuZXh0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmxhbmtMaW5lICYmICFuZXh0TGluZS50cmltKCkpIHsgLy8gQ2hlY2sgaWYgY3VycmVudCBsaW5lIGlzIGJsYW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdyArPSByYXdMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHJhd0xpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbmV4dExpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGl0ZW0gZW5kZWQgd2l0aCBhIGJsYW5rIGxpbmUsIHRoZSBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL1xcbiAqXFxuICokLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHNXaXRoQmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaXN0YXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgaXNjaGVja2VkO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0YXNrIGxpc3QgaXRlbXNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgICAgICAgICBpc3Rhc2sgPSAvXlxcW1sgeFhdXFxdIC8uZXhlYyhpdGVtQ29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXN0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc2NoZWNrZWQgPSBpc3Rhc2tbMF0gIT09ICdbIF0gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGl0ZW1Db250ZW50cy5yZXBsYWNlKC9eXFxbWyB4WF1cXF0gKy8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICB0YXNrOiAhIWlzdGFzayxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW1Db250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxpc3QucmF3ICs9IHJhdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gcmF3LnRyaW1SaWdodCgpO1xuICAgICAgICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnRleHQgPSBpdGVtQ29udGVudHMudHJpbVJpZ2h0KCk7XG4gICAgICAgICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnRyaW1SaWdodCgpO1xuICAgICAgICAgICAgLy8gSXRlbSBjaGlsZCB0b2tlbnMgaGFuZGxlZCBoZXJlIGF0IGVuZCBiZWNhdXNlIHdlIG5lZWRlZCB0byBoYXZlIHRoZSBmaW5hbCBpdGVtIHRvIHRyaW0gaXQgZmlyc3RcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGlzdC5pdGVtc1tpXS50b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKGxpc3QuaXRlbXNbaV0udGV4dCwgW10pO1xuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBsaXN0IHNob3VsZCBiZSBsb29zZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFjZXJzID0gbGlzdC5pdGVtc1tpXS50b2tlbnMuZmlsdGVyKHQgPT4gdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVMaW5lQnJlYWtzID0gc3BhY2Vycy5sZW5ndGggPiAwICYmIHNwYWNlcnMuc29tZSh0ID0+IC9cXG4uKlxcbi8udGVzdCh0LnJhdykpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gaGFzTXVsdGlwbGVMaW5lQnJlYWtzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBhbGwgaXRlbXMgdG8gbG9vc2UgaWYgbGlzdCBpcyBsb29zZVxuICAgICAgICAgICAgaWYgKGxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5pdGVtc1tpXS5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5odG1sLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHByZTogIXRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgJiYgKGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScpLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHBhcmFncmFwaC50eXBlID0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIHBhcmFncmFwaC50b2tlbnMgPSB0aGlzLmxleGVyLmlubGluZSh0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWYoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNhcFsyXSA/IGNhcFsyXS5yZXBsYWNlKC9ePCguKik+JC8sICckMScpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogY2FwWzNdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVmJyxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWJsZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50YWJsZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHNwbGl0Q2VsbHMoY2FwWzFdKS5tYXAoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGMsIHRva2VuczogW10gfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgICAgICAgICAgcm93czogY2FwWzNdICYmIGNhcFszXS50cmltKCkgPyBjYXBbM10ucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID09PSBpdGVtLmFsaWduLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBsID0gaXRlbS5hbGlnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGksIGosIGssIHJvdztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsaWduID0gaXRlbS5hbGlnbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGwgPSBpdGVtLnJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5yb3dzW2ldID0gc3BsaXRDZWxscyhpdGVtLnJvd3NbaV0sIGl0ZW0uaGVhZGVyLmxlbmd0aCkubWFwKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogYywgdG9rZW5zOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgY2hpbGQgdG9rZW5zIGluc2lkZSBoZWFkZXJzIGFuZCBjZWxsc1xuICAgICAgICAgICAgICAgIC8vIGhlYWRlciBjaGlsZCB0b2tlbnNcbiAgICAgICAgICAgICAgICBsID0gaXRlbS5oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5oZWFkZXJbal0udG9rZW5zID0gdGhpcy5sZXhlci5pbmxpbmUoaXRlbS5oZWFkZXJbal0udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNlbGwgY2hpbGQgdG9rZW5zXG4gICAgICAgICAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBpdGVtLnJvd3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCByb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1trXS50b2tlbnMgPSB0aGlzLmxleGVyLmlubGluZShyb3dba10udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGhlYWRpbmcoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGhlYWRpbmcuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzFdLFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2FwWzFdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgICAgIDogY2FwWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGV4dChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2FwWzBdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlc2NhcGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmVzY2FwZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dDogZXNjYXBlKGNhcFsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFnKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148KHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148XFwvKHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICAgICAgICAgICAgPyAndGV4dCdcbiAgICAgICAgICAgICAgICAgICAgOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgICAgICAgICBpblJhd0Jsb2NrOiB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2ssXG4gICAgICAgICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKSlcbiAgICAgICAgICAgICAgICAgICAgOiBjYXBbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGluayhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubGluay5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRVcmwgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgL148Ly50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICAgICAgICAgIGlmICghKC8+JC8udGVzdCh0cmltbWVkVXJsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbmRpbmcgYW5nbGUgYnJhY2tldCBjYW5ub3QgYmUgZXNjYXBlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJ0cmltU2xhc2ggPSBydHJpbSh0cmltbWVkVXJsLnNsaWNlKDAsIC0xKSwgJ1xcXFwnKTtcbiAgICAgICAgICAgICAgICBpZiAoKHRyaW1tZWRVcmwubGVuZ3RoIC0gcnRyaW1TbGFzaC5sZW5ndGgpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFBhcmVuSW5kZXggPSBmaW5kQ2xvc2luZ0JyYWNrZXQoY2FwWzJdLCAnKCknKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhcmVuSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGNhcFswXS5pbmRleE9mKCchJykgPT09IDAgPyA1IDogNDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua0xlbiA9IHN0YXJ0ICsgY2FwWzFdLmxlbmd0aCArIGxhc3RQYXJlbkluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcFszXSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBocmVmID0gY2FwWzJdO1xuICAgICAgICAgICAgbGV0IHRpdGxlID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgcGVkYW50aWMgaHJlZiBhbmQgdGl0bGVcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zbGljZSgxLCAtMSkgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICgvXjwvLnRlc3QoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZWRhbnRpYyBhbGxvd3Mgc3RhcnRpbmcgYW5nbGUgYnJhY2tldCB3aXRob3V0IGVuZGluZyBhbmdsZSBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYgPyBocmVmLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogaHJlZixcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUgPyB0aXRsZS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IHRpdGxlXG4gICAgICAgICAgICB9LCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgICAgICBsZXQgY2FwO1xuICAgICAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICAgICAgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICBsZXQgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgICAgICBsaW5rID0gbGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwgbGluaywgY2FwWzBdLCB0aGlzLmxleGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIgPSAnJykge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5sRGVsaW0uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBfIGNhbid0IGJlIGJldHdlZW4gdHdvIGFscGhhbnVtZXJpY3MuIFxccHtMfVxccHtOfSBpbmNsdWRlcyBub24tZW5nbGlzaCBhbHBoYWJldC9udW1iZXJzIGFzIHdlbGxcbiAgICAgICAgaWYgKG1hdGNoWzNdICYmIHByZXZDaGFyLm1hdGNoKC9bXFxwe0x9XFxwe059XS91KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV4dENoYXIgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCAnJztcbiAgICAgICAgaWYgKCFuZXh0Q2hhciB8fCAhcHJldkNoYXIgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpIHtcbiAgICAgICAgICAgIC8vIHVuaWNvZGUgUmVnZXggY291bnRzIGVtb2ppIGFzIDEgY2hhcjsgc3ByZWFkIGludG8gYXJyYXkgZm9yIHByb3BlciBjb3VudCAodXNlZCBtdWx0aXBsZSB0aW1lcyBiZWxvdylcbiAgICAgICAgICAgIGNvbnN0IGxMZW5ndGggPSBbLi4ubWF0Y2hbMF1dLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgckRlbGltLCByTGVuZ3RoLCBkZWxpbVRvdGFsID0gbExlbmd0aCwgbWlkRGVsaW1Ub3RhbCA9IDA7XG4gICAgICAgICAgICBjb25zdCBlbmRSZWcgPSBtYXRjaFswXVswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kO1xuICAgICAgICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyBDbGlwIG1hc2tlZFNyYyB0byBzYW1lIHNlY3Rpb24gb2Ygc3RyaW5nIGFzIHNyYyAobW92ZSB0byBsZXhlcj8pXG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJEZWxpbSA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IG1hdGNoWzZdO1xuICAgICAgICAgICAgICAgIGlmICghckRlbGltKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBzaW5nbGUgKiBpbiBfX2FiYyphYmNfX1xuICAgICAgICAgICAgICAgIHJMZW5ndGggPSBbLi4uckRlbGltXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7IC8vIGZvdW5kIGFub3RoZXIgTGVmdCBEZWxpbVxuICAgICAgICAgICAgICAgICAgICBkZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkgeyAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgICAgICAgICAgICBpZiAobExlbmd0aCAlIDMgJiYgISgobExlbmd0aCArIHJMZW5ndGgpICUgMykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZERlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBDb21tb25NYXJrIEVtcGhhc2lzIFJ1bGVzIDktMTBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxpbVRvdGFsIC09IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGltVG90YWwgPiAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gSGF2ZW4ndCBmb3VuZCBlbm91Z2ggY2xvc2luZyBkZWxpbWl0ZXJzXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIGNoYXJhY3RlcnMuICphKioqIC0+ICphKlxuICAgICAgICAgICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IFsuLi5zcmNdLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGggKyAxKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlICdzdHJvbmcnIGlmIHNtYWxsZXN0IGRlbGltaXRlciBoYXMgZXZlbiBjaGFyIGNvdW50LiAqKmEqKipcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gcmF3LnNsaWNlKDIsIC0yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3Ryb25nJyxcbiAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2Rlc3BhbihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaGFzTm9uU3BhY2VDaGFycyA9IC9bXiBdLy50ZXN0KHRleHQpO1xuICAgICAgICAgICAgY29uc3QgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMgPSAvXiAvLnRlc3QodGV4dCkgJiYgLyAkLy50ZXN0KHRleHQpO1xuICAgICAgICAgICAgaWYgKGhhc05vblNwYWNlQ2hhcnMgJiYgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSBlc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb2Rlc3BhbicsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBicihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5kZWwuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWwnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFsyXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKGNhcFsyXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYXV0b2xpbmsuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmwoc3JjLCBtYW5nbGUpIHtcbiAgICAgICAgbGV0IGNhcDtcbiAgICAgICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnVybC5leGVjKHNyYykpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHByZXZDYXBaZXJvO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkNhcFplcm8gPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuaW5saW5lLl9iYWNrcGVkYWwuZXhlYyhjYXBbMF0pWzBdO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXZDYXBaZXJvICE9PSBjYXBbMF0pO1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FwWzFdID09PSAnd3d3LicpIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9ICdodHRwOi8vJyArIGNhcFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlubGluZVRleHQoc3JjLCBzbWFydHlwYW50cykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/ICh0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSkpIDogY2FwWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSh0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMgPyBzbWFydHlwYW50cyhjYXBbMF0pIDogY2FwWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG4vLyBOb3QgYWxsIHJ1bGVzIGFyZSBkZWZpbmVkIGluIHRoZSBvYmplY3QgbGl0ZXJhbFxuLy8gQHRzLWV4cGVjdC1lcnJvclxuY29uc3QgYmxvY2sgPSB7XG4gICAgbmV3bGluZTogL14oPzogKig/OlxcbnwkKSkrLyxcbiAgICBjb2RlOiAvXiggezR9W15cXG5dKyg/Olxcbig/OiAqKD86XFxufCQpKSopPykrLyxcbiAgICBmZW5jZXM6IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSooPzpcXG58JCkpfH57Myx9KShbXlxcbl0qKSg/OlxcbnwkKSg/OnwoW1xcc1xcU10qPykoPzpcXG58JCkpKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS8sXG4gICAgaHI6IC9eIHswLDN9KCg/Oi1bXFx0IF0qKXszLH18KD86X1sgXFx0XSopezMsfXwoPzpcXCpbIFxcdF0qKXszLH0pKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14gezAsM30oI3sxLDZ9KSg/PVxcc3wkKSguKikoPzpcXG4rfCQpLyxcbiAgICBibG9ja3F1b3RlOiAvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvLFxuICAgIGxpc3Q6IC9eKCB7MCwzfWJ1bGwpKFsgXFx0XVteXFxuXSs/KT8oPzpcXG58JCkvLFxuICAgIGh0bWw6ICdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICAgICArICc8KHNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW1xcXFxzPl1bXFxcXHNcXFxcU10qPyg/OjwvXFxcXDE+W15cXFxcbl0qXFxcXG4rfCQpJyAvLyAoMSlcbiAgICAgICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICAgICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/KD86XFxcXD8+XFxcXG4qfCQpJyAvLyAoMylcbiAgICAgICAgKyAnfDwhW0EtWl1bXFxcXHNcXFxcU10qPyg/Oj5cXFxcbip8JCknIC8vICg0KVxuICAgICAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICAgICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg2KVxuICAgICAgICArICd8PCg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpKFthLXpdW1xcXFx3LV0qKSg/OmF0dHJpYnV0ZSkqPyAqLz8+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIG9wZW4gdGFnXG4gICAgICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgICAgICsgJyknLFxuICAgIGRlZjogL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuICopPyhbXjxcXHNdW15cXHNdKnw8Lio/PikoPzooPzogKyg/OlxcbiAqKT98ICpcXG4gKikodGl0bGUpKT8gKig/Olxcbit8JCkvLFxuICAgIHRhYmxlOiBub29wVGVzdCxcbiAgICBsaGVhZGluZzogL14oKD86KD8hXmJ1bGwgKS58XFxuKD8hXFxufGJ1bGwgKSkrPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICAvLyByZWdleCB0ZW1wbGF0ZSwgcGxhY2Vob2xkZXJzIHdpbGwgYmUgcmVwbGFjZWQgYWNjb3JkaW5nIHRvIGRpZmZlcmVudCBwYXJhZ3JhcGhcbiAgICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gICAgX3BhcmFncmFwaDogL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sfHRhYmxlfCArXFxuKVteXFxuXSspKikvLFxuICAgIHRleHQ6IC9eW15cXG5dKy9cbn07XG5ibG9jay5fbGFiZWwgPSAvKD8hXFxzKlxcXSkoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSsvO1xuYmxvY2suX3RpdGxlID0gLyg/OlwiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCdbXidcXG5dKig/OlxcblteJ1xcbl0rKSpcXG4/J3xcXChbXigpXSpcXCkpLztcbmJsb2NrLmRlZiA9IGVkaXQoYmxvY2suZGVmKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGJsb2NrLl9sYWJlbClcbiAgICAucmVwbGFjZSgndGl0bGUnLCBibG9jay5fdGl0bGUpXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG5ibG9jay5saXN0SXRlbVN0YXJ0ID0gZWRpdCgvXiggKikoYnVsbCkgKi8pXG4gICAgLnJlcGxhY2UoJ2J1bGwnLCBibG9jay5idWxsZXQpXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5saXN0ID0gZWRpdChibG9jay5saXN0KVxuICAgIC5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgICAucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKVxuICAgIC5yZXBsYWNlKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrLmRlZi5zb3VyY2UgKyAnKScpXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5fdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJ1xuICAgICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgICArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbidcbiAgICArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJ1xuICAgICsgJ3x0cmFja3x1bCc7XG5ibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuYmxvY2suaHRtbCA9IGVkaXQoYmxvY2suaHRtbCwgJ2knKVxuICAgIC5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpXG4gICAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpXG4gICAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5saGVhZGluZyA9IGVkaXQoYmxvY2subGhlYWRpbmcpXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KSAvLyBsaXN0cyBjYW4gaW50ZXJydXB0XG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gICAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpXG4gICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuYmxvY2suYmxvY2txdW90ZSA9IGVkaXQoYmxvY2suYmxvY2txdW90ZSlcbiAgICAucmVwbGFjZSgncGFyYWdyYXBoJywgYmxvY2sucGFyYWdyYXBoKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5ibG9jay5ub3JtYWwgPSB7IC4uLmJsb2NrIH07XG4vKipcbiAqIEdGTSBCbG9jayBHcmFtbWFyXG4gKi9cbmJsb2NrLmdmbSA9IHtcbiAgICAuLi5ibG9jay5ub3JtYWwsXG4gICAgdGFibGU6ICdeICooW15cXFxcbiBdLipcXFxcfC4qKVxcXFxuJyAvLyBIZWFkZXJcbiAgICAgICAgKyAnIHswLDN9KD86XFxcXHwgKik/KDo/LSs6PyAqKD86XFxcXHwgKjo/LSs6PyAqKSopKD86XFxcXHwgKik/JyAvLyBBbGlnblxuICAgICAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcbn07XG5ibG9jay5nZm0udGFibGUgPSBlZGl0KGJsb2NrLmdmbS50YWJsZSlcbiAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyB0YWJsZXMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5nZm0ucGFyYWdyYXBoID0gZWRpdChibG9jay5fcGFyYWdyYXBoKVxuICAgIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKVxuICAgIC5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXggaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAgIC5yZXBsYWNlKCd0YWJsZScsIGJsb2NrLmdmbS50YWJsZSkgLy8gaW50ZXJydXB0IHBhcmFncmFwaHMgd2l0aCB0YWJsZVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gKi9cbmJsb2NrLnBlZGFudGljID0ge1xuICAgIC4uLmJsb2NrLm5vcm1hbCxcbiAgICBodG1sOiBlZGl0KCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKSdcbiAgICAgICAgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKVxuICAgICAgICAucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KVxuICAgICAgICAucmVwbGFjZSgvdGFnL2csICcoPyEoPzonXG4gICAgICAgICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInXG4gICAgICAgICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJ1xuICAgICAgICArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArKFtcIihdW15cXG5dK1tcIildKSk/ICooPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXigjezEsNn0pKC4qKSg/Olxcbit8JCkvLFxuICAgIGZlbmNlczogbm9vcFRlc3QsXG4gICAgbGhlYWRpbmc6IC9eKC4rPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICBwYXJhZ3JhcGg6IGVkaXQoYmxvY2subm9ybWFsLl9wYXJhZ3JhcGgpXG4gICAgICAgIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAgICAgICAucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJylcbiAgICAgICAgLnJlcGxhY2UoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICAgICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgICAgICAucmVwbGFjZSgnfGZlbmNlcycsICcnKVxuICAgICAgICAucmVwbGFjZSgnfGxpc3QnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3xodG1sJywgJycpXG4gICAgICAgIC5nZXRSZWdleCgpXG59O1xuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG4vLyBOb3QgYWxsIHJ1bGVzIGFyZSBkZWZpbmVkIGluIHRoZSBvYmplY3QgbGl0ZXJhbFxuLy8gQHRzLWV4cGVjdC1lcnJvclxuY29uc3QgaW5saW5lID0ge1xuICAgIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gICAgYXV0b2xpbms6IC9ePChzY2hlbWU6W15cXHNcXHgwMC1cXHgxZjw+XSp8ZW1haWwpPi8sXG4gICAgdXJsOiBub29wVGVzdCxcbiAgICB0YWc6ICdeY29tbWVudCdcbiAgICAgICAgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICAgICAgKyAnfF48W2EtekEtWl1bXFxcXHctXSooPzphdHRyaWJ1dGUpKj9cXFxccyovPz4nIC8vIG9wZW4gdGFnXG4gICAgICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICAgICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICAgICAgKyAnfF48IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nLFxuICAgIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgICByZWZsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcWyhyZWYpXFxdLyxcbiAgICBub2xpbms6IC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LyxcbiAgICByZWZsaW5rU2VhcmNoOiAncmVmbGlua3xub2xpbmsoPyFcXFxcKCknLFxuICAgIGVtU3Ryb25nOiB7XG4gICAgICAgIGxEZWxpbTogL14oPzpcXCorKD86KCg/IVxcKilbcHVuY3RdKXxbXlxccypdKSl8Xl8rKD86KCg/IV8pW3B1bmN0XSl8KFteXFxzX10pKS8sXG4gICAgICAgIC8vICAgICAgICAgKDEpIGFuZCAoMikgY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXIuICgzKSBhbmQgKDQpIGNhbiBvbmx5IGJlIExlZnQuICAoNSkgYW5kICg2KSBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQuXG4gICAgICAgIC8vICAgICAgICAgfCBTa2lwIG9ycGhhbiBpbnNpZGUgc3Ryb25nICAgICAgfCBDb25zdW1lIHRvIGRlbGltIHwgKDEpICMqKiogICAgICAgICAgICAgIHwgKDIpIGEqKiojLCBhKioqICAgICAgICAgICAgICAgICAgICB8ICgzKSAjKioqYSwgKioqYSAgICAgICAgICAgICAgICAgIHwgKDQpICoqKiMgICAgICAgICAgICAgICAgIHwgKDUpICMqKiojICAgICAgICAgICAgICAgICAgICAgICAgIHwgKDYpIGEqKiphXG4gICAgICAgIHJEZWxpbUFzdDogL15bXl8qXSo/X19bXl8qXSo/XFwqW15fKl0qPyg/PV9fKXxbXipdKyg/PVteKl0pfCg/IVxcKilbcHVuY3RdKFxcKispKD89W1xcc118JCl8W15wdW5jdFxcc10oXFwqKykoPyFcXCopKD89W3B1bmN0XFxzXXwkKXwoPyFcXCopW3B1bmN0XFxzXShcXCorKSg/PVtecHVuY3RcXHNdKXxbXFxzXShcXCorKSg/IVxcKikoPz1bcHVuY3RdKXwoPyFcXCopW3B1bmN0XShcXCorKSg/IVxcKikoPz1bcHVuY3RdKXxbXnB1bmN0XFxzXShcXCorKSg/PVtecHVuY3RcXHNdKS8sXG4gICAgICAgIHJEZWxpbVVuZDogL15bXl8qXSo/XFwqXFwqW15fKl0qP19bXl8qXSo/KD89XFwqXFwqKXxbXl9dKyg/PVteX10pfCg/IV8pW3B1bmN0XShfKykoPz1bXFxzXXwkKXxbXnB1bmN0XFxzXShfKykoPyFfKSg/PVtwdW5jdFxcc118JCl8KD8hXylbcHVuY3RcXHNdKF8rKSg/PVtecHVuY3RcXHNdKXxbXFxzXShfKykoPyFfKSg/PVtwdW5jdF0pfCg/IV8pW3B1bmN0XShfKykoPyFfKSg/PVtwdW5jdF0pLyAvLyBeLSBOb3QgYWxsb3dlZCBmb3IgX1xuICAgIH0sXG4gICAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICAgIGRlbDogbm9vcFRlc3QsXG4gICAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLyxcbiAgICBwdW5jdHVhdGlvbjogL14oKD8hWypfXSlbXFxzcHVuY3R1YXRpb25dKS9cbn07XG4vLyBsaXN0IG9mIHVuaWNvZGUgcHVuY3R1YXRpb24gbWFya3MsIHBsdXMgYW55IG1pc3NpbmcgY2hhcmFjdGVycyBmcm9tIENvbW1vbk1hcmsgc3BlY1xuaW5saW5lLl9wdW5jdHVhdGlvbiA9ICdcXFxccHtQfSQrPD0+YF58fic7XG5pbmxpbmUucHVuY3R1YXRpb24gPSBlZGl0KGlubGluZS5wdW5jdHVhdGlvbiwgJ3UnKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuLy8gc2VxdWVuY2VzIGVtIHNob3VsZCBza2lwIG92ZXIgW3RpdGxlXShsaW5rKSwgYGNvZGVgLCA8aHRtbD5cbmlubGluZS5ibG9ja1NraXAgPSAvXFxbW15bXFxdXSo/XFxdXFwoW15cXChcXCldKj9cXCl8YFteYF0qP2B8PFtePD5dKj8+L2c7XG5pbmxpbmUuYW55UHVuY3R1YXRpb24gPSAvXFxcXFtwdW5jdF0vZztcbmlubGluZS5fZXNjYXBlcyA9IC9cXFxcKFtwdW5jdF0pL2c7XG5pbmxpbmUuX2NvbW1lbnQgPSBlZGl0KGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcbmlubGluZS5lbVN0cm9uZy5sRGVsaW0gPSBlZGl0KGlubGluZS5lbVN0cm9uZy5sRGVsaW0sICd1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgPSBlZGl0KGlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QsICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kID0gZWRpdChpbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kLCAnZ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLmFueVB1bmN0dWF0aW9uID0gZWRpdChpbmxpbmUuYW55UHVuY3R1YXRpb24sICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuX2VzY2FwZXMgPSBlZGl0KGlubGluZS5fZXNjYXBlcywgJ2d1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5fc2NoZW1lID0gL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vO1xuaW5saW5lLl9lbWFpbCA9IC9bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyhAKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrKD8hWy1fXSkvO1xuaW5saW5lLmF1dG9saW5rID0gZWRpdChpbmxpbmUuYXV0b2xpbmspXG4gICAgLnJlcGxhY2UoJ3NjaGVtZScsIGlubGluZS5fc2NoZW1lKVxuICAgIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcbmlubGluZS50YWcgPSBlZGl0KGlubGluZS50YWcpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUuX2NvbW1lbnQpXG4gICAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZS5fYXR0cmlidXRlKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLl9sYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG5pbmxpbmUuX2hyZWYgPSAvPCg/OlxcXFwufFteXFxuPD5cXFxcXSkrPnxbXlxcc1xceDAwLVxceDFmXSovO1xuaW5saW5lLl90aXRsZSA9IC9cIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnKD86XFxcXCc/fFteJ1xcXFxdKSonfFxcKCg/OlxcXFxcXCk/fFteKVxcXFxdKSpcXCkvO1xuaW5saW5lLmxpbmsgPSBlZGl0KGlubGluZS5saW5rKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgLnJlcGxhY2UoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gICAgLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSlcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5yZWZsaW5rID0gZWRpdChpbmxpbmUucmVmbGluaylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgIC5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUubm9saW5rID0gZWRpdChpbmxpbmUubm9saW5rKVxuICAgIC5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lLnJlZmxpbmtTZWFyY2gsICdnJylcbiAgICAucmVwbGFjZSgncmVmbGluaycsIGlubGluZS5yZWZsaW5rKVxuICAgIC5yZXBsYWNlKCdub2xpbmsnLCBpbmxpbmUubm9saW5rKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuaW5saW5lLm5vcm1hbCA9IHsgLi4uaW5saW5lIH07XG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cbmlubGluZS5wZWRhbnRpYyA9IHtcbiAgICAuLi5pbmxpbmUubm9ybWFsLFxuICAgIHN0cm9uZzoge1xuICAgICAgICBzdGFydDogL15fX3xcXCpcXCovLFxuICAgICAgICBtaWRkbGU6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICAgICAgICBlbmRBc3Q6IC9cXCpcXCooPyFcXCopL2csXG4gICAgICAgIGVuZFVuZDogL19fKD8hXykvZ1xuICAgIH0sXG4gICAgZW06IHtcbiAgICAgICAgc3RhcnQ6IC9eX3xcXCovLFxuICAgICAgICBtaWRkbGU6IC9eKClcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKXxeXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXykvLFxuICAgICAgICBlbmRBc3Q6IC9cXCooPyFcXCopL2csXG4gICAgICAgIGVuZFVuZDogL18oPyFfKS9nXG4gICAgfSxcbiAgICBsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFwoKC4qPylcXCkvKVxuICAgICAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgICAgIC5nZXRSZWdleCgpXG59O1xuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuaW5saW5lLmdmbSA9IHtcbiAgICAuLi5pbmxpbmUubm9ybWFsLFxuICAgIGVzY2FwZTogZWRpdChpbmxpbmUuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgICBfZXh0ZW5kZWRfZW1haWw6IC9bQS1aYS16MC05Ll8rLV0rKEApW2EtekEtWjAtOS1fXSsoPzpcXC5bYS16QS1aMC05LV9dKlthLXpBLVowLTldKSsoPyFbLV9dKS8sXG4gICAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoW1xcc1xcU10qP1teXFxzfl0pXFwxKD89W15+XXwkKS8sXG4gICAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn07XG5pbmxpbmUuZ2ZtLnVybCA9IGVkaXQoaW5saW5lLmdmbS51cmwsICdpJylcbiAgICAucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuZ2ZtLl9leHRlbmRlZF9lbWFpbClcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuaW5saW5lLmJyZWFrcyA9IHtcbiAgICAuLi5pbmxpbmUuZ2ZtLFxuICAgIGJyOiBlZGl0KGlubGluZS5icikucmVwbGFjZSgnezIsfScsICcqJykuZ2V0UmVnZXgoKSxcbiAgICB0ZXh0OiBlZGl0KGlubGluZS5nZm0udGV4dClcbiAgICAgICAgLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgICAgIC5nZXRSZWdleCgpXG59O1xuXG4vKipcbiAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICAgIHJldHVybiB0ZXh0XG4gICAgICAgIC8vIGVtLWRhc2hlc1xuICAgICAgICAucmVwbGFjZSgvLS0tL2csICdcXHUyMDE0JylcbiAgICAgICAgLy8gZW4tZGFzaGVzXG4gICAgICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgICAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgJyQxXFx1MjAxOCcpXG4gICAgICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAgICAgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAgICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFx1MjAxZCcpXG4gICAgICAgIC8vIGVsbGlwc2VzXG4gICAgICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn1cbi8qKlxuICogbWFuZ2xlIGVtYWlsIGFkZHJlc3Nlc1xuICovXG5mdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICAgIGxldCBvdXQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2ggPSBNYXRoLnJhbmRvbSgpID4gMC41XG4gICAgICAgICAgICA/ICd4JyArIHRleHQuY2hhckNvZGVBdChpKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIDogdGV4dC5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKCk7XG4gICAgICAgIG91dCArPSAnJiMnICsgY2ggKyAnOyc7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cbmNsYXNzIF9MZXhlciB7XG4gICAgdG9rZW5zO1xuICAgIG9wdGlvbnM7XG4gICAgc3RhdGU7XG4gICAgdG9rZW5pemVyO1xuICAgIGlubGluZVF1ZXVlO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVG9rZW5MaXN0IGNhbm5vdCBiZSBjcmVhdGVkIGluIG9uZSBnb1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBleHBvcnRzLmRlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplciB8fCBuZXcgX1Rva2VuaXplcigpO1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMudG9rZW5pemVyLmxleGVyID0gdGhpcztcbiAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaW5MaW5rOiBmYWxzZSxcbiAgICAgICAgICAgIGluUmF3QmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgdG9wOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bGVzID0ge1xuICAgICAgICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgICAgICAgIGlubGluZTogaW5saW5lLm5vcm1hbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLnBlZGFudGljO1xuICAgICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLnBlZGFudGljO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2suZ2ZtO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuYnJlYWtzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmdmbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgUnVsZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHJ1bGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBpbmxpbmVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4KHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBJbmxpbmUgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgX0xleGVyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICBsZXgoc3JjKSB7XG4gICAgICAgIHNyYyA9IHNyY1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpO1xuICAgICAgICB0aGlzLmJsb2NrVG9rZW5zKHNyYywgdGhpcy50b2tlbnMpO1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKG5leHQgPSB0aGlzLmlubGluZVF1ZXVlLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKG5leHQuc3JjLCBuZXh0LnRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICBibG9ja1Rva2VucyhzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXiggKikoXFx0KykvZ20sIChfLCBsZWFkaW5nLCB0YWJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmcgKyAnICAgICcucmVwZWF0KHRhYnMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IGxhc3RUb2tlbjtcbiAgICAgICAgbGV0IGN1dFNyYztcbiAgICAgICAgbGV0IGxhc3RQYXJhZ3JhcGhDbGlwcGVkO1xuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5sZW5ndGggPT09IDEgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbW92ZSBpdCB0aGVyZSBzbyB0aGF0IHdlIGRvbid0IGdldCB1bmVjZXNzYXJ5IHBhcmFncmFwaCB0YWdzXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0ucmF3ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvZGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZlbmNlc1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlYWRpbmdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJsb2NrcXVvdGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlzdFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGlzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBodG1sXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlZlxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLmxpbmtzW3Rva2VuLnRhZ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGFibGUgKGdmbSlcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhYmxlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHBhcmFncmFwaCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgICAgICAgIGN1dFNyYyA9IHNyYztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jay5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUudG9wICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBhcmFncmFwaChjdXRTcmMpKSkge1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXJhZ3JhcGhDbGlwcGVkICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFBhcmFncmFwaENsaXBwZWQgPSAoY3V0U3JjLmxlbmd0aCAhPT0gc3JjLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgaW5saW5lKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wdXNoKHsgc3JjLCB0b2tlbnMgfSk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZy9Db21waWxpbmdcbiAgICAgKi9cbiAgICBpbmxpbmVUb2tlbnMoc3JjLCB0b2tlbnMgPSBbXSkge1xuICAgICAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjO1xuICAgICAgICAvLyBTdHJpbmcgd2l0aCBsaW5rcyBtYXNrZWQgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggZW0gYW5kIHN0cm9uZ1xuICAgICAgICBsZXQgbWFza2VkU3JjID0gc3JjO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGxldCBrZWVwUHJldkNoYXIsIHByZXZDaGFyO1xuICAgICAgICAvLyBNYXNrIG91dCByZWZsaW5rc1xuICAgICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2guZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rcy5pbmNsdWRlcyhtYXRjaFswXS5zbGljZShtYXRjaFswXS5sYXN0SW5kZXhPZignWycpICsgMSwgLTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2gubGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgJ2EnLnJlcGVhdChtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgZXNjYXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24uZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJysrJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBQcmV2Q2hhcikge1xuICAgICAgICAgICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZWVwUHJldkNoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZVxuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoeyBsZXhlcjogdGhpcyB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzY2FwZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFnKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiclxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0b2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYywgbWFuZ2xlKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXJsIChnZm0pXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaW5MaW5rICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnVybChzcmMsIG1hbmdsZSkpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGlubGluZVRleHQgY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZS5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaW5saW5lVGV4dChjdXRTcmMsIHNtYXJ0eXBhbnRzKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5zbGljZSgtMSkgIT09ICdfJykgeyAvLyBUcmFjayBwcmV2Q2hhciBiZWZvcmUgc3RyaW5nIG9mIF9fX18gc3RhcnRlZFxuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtlZXBQcmV2Q2hhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cbmNsYXNzIF9SZW5kZXJlciB7XG4gICAgb3B0aW9ucztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZXhwb3J0cy5kZWZhdWx0cztcbiAgICB9XG4gICAgY29kZShjb2RlLCBpbmZvc3RyaW5nLCBlc2NhcGVkKSB7XG4gICAgICAgIGNvbnN0IGxhbmcgPSAoaW5mb3N0cmluZyB8fCAnJykubWF0Y2goL15cXFMqLyk/LlswXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgICAgICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29kZSA9IG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXG4kLywgJycpICsgJ1xcbic7XG4gICAgICAgIGlmICghbGFuZykge1xuICAgICAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICAgICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgICAgICAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgICAgICAgICArIGVzY2FwZShsYW5nKVxuICAgICAgICAgICAgKyAnXCI+J1xuICAgICAgICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICB9XG4gICAgYmxvY2txdW90ZShxdW90ZSkge1xuICAgICAgICByZXR1cm4gYDxibG9ja3F1b3RlPlxcbiR7cXVvdGV9PC9ibG9ja3F1b3RlPlxcbmA7XG4gICAgfVxuICAgIGh0bWwoaHRtbCwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIGhlYWRpbmcodGV4dCwgbGV2ZWwsIHJhdywgc2x1Z2dlcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcklkcykge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4ICsgc2x1Z2dlci5zbHVnKHJhdyk7XG4gICAgICAgICAgICByZXR1cm4gYDxoJHtsZXZlbH0gaWQ9XCIke2lkfVwiPiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlnbm9yZSBJRHNcbiAgICAgICAgcmV0dXJuIGA8aCR7bGV2ZWx9PiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgIH1cbiAgICBocigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG4gICAgfVxuICAgIGxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJztcbiAgICAgICAgY29uc3Qgc3RhcnRhdHQgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gICAgICAgIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRhdHQgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfVxuICAgIGxpc3RpdGVtKHRleHQsIHRhc2ssIGNoZWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGA8bGk+JHt0ZXh0fTwvbGk+XFxuYDtcbiAgICB9XG4gICAgY2hlY2tib3goY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gJzxpbnB1dCAnXG4gICAgICAgICAgICArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogJycpXG4gICAgICAgICAgICArICdkaXNhYmxlZD1cIlwiIHR5cGU9XCJjaGVja2JveFwiJ1xuICAgICAgICAgICAgKyAodGhpcy5vcHRpb25zLnhodG1sID8gJyAvJyA6ICcnKVxuICAgICAgICAgICAgKyAnPiAnO1xuICAgIH1cbiAgICBwYXJhZ3JhcGgodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxwPiR7dGV4dH08L3A+XFxuYDtcbiAgICB9XG4gICAgdGFibGUoaGVhZGVyLCBib2R5KSB7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgYm9keSA9IGA8dGJvZHk+JHtib2R5fTwvdGJvZHk+YDtcbiAgICAgICAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICAgICAgICAgKyAnPHRoZWFkPlxcbidcbiAgICAgICAgICAgICsgaGVhZGVyXG4gICAgICAgICAgICArICc8L3RoZWFkPlxcbidcbiAgICAgICAgICAgICsgYm9keVxuICAgICAgICAgICAgKyAnPC90YWJsZT5cXG4nO1xuICAgIH1cbiAgICB0YWJsZXJvdyhjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBgPHRyPlxcbiR7Y29udGVudH08L3RyPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlY2VsbChjb250ZW50LCBmbGFncykge1xuICAgICAgICBjb25zdCB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgICAgIGNvbnN0IHRhZyA9IGZsYWdzLmFsaWduXG4gICAgICAgICAgICA/IGA8JHt0eXBlfSBhbGlnbj1cIiR7ZmxhZ3MuYWxpZ259XCI+YFxuICAgICAgICAgICAgOiBgPCR7dHlwZX0+YDtcbiAgICAgICAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyBgPC8ke3R5cGV9PlxcbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNwYW4gbGV2ZWwgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBzdHJvbmcodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxzdHJvbmc+JHt0ZXh0fTwvc3Ryb25nPmA7XG4gICAgfVxuICAgIGVtKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8ZW0+JHt0ZXh0fTwvZW0+YDtcbiAgICB9XG4gICAgY29kZXNwYW4odGV4dCkge1xuICAgICAgICByZXR1cm4gYDxjb2RlPiR7dGV4dH08L2NvZGU+YDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0ZXh0fTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwodGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMuYmFzZVVybCwgaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cImA7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9IGAgdGl0bGU9XCIke3RpdGxlfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBUZXh0UmVuZGVyZXJcbiAqIHJldHVybnMgb25seSB0aGUgdGV4dHVhbCBwYXJ0IG9mIHRoZSB0b2tlblxuICovXG5jbGFzcyBfVGV4dFJlbmRlcmVyIHtcbiAgICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgICBzdHJvbmcodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZW0odGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgY29kZXNwYW4odGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZGVsKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGh0bWwodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgdGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBsaW5rKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfVxuICAgIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfVxuICAgIGJyKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuXG4vKipcbiAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICovXG5jbGFzcyBfU2x1Z2dlciB7XG4gICAgc2VlbjtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZWVuID0ge307XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAvLyByZW1vdmUgaHRtbCB0YWdzXG4gICAgICAgICAgICAucmVwbGFjZSgvPFshXFwvYS16XS4qPz4vaWcsICcnKVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHVud2FudGVkIGNoYXJzXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzL2csICctJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IHNhZmUgKHVuaXF1ZSkgc2x1ZyB0byB1c2VcbiAgICAgKi9cbiAgICBnZXROZXh0U2FmZVNsdWcob3JpZ2luYWxTbHVnLCBpc0RyeVJ1bikge1xuICAgICAgICBsZXQgc2x1ZyA9IG9yaWdpbmFsU2x1ZztcbiAgICAgICAgbGV0IG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gMDtcbiAgICAgICAgaWYgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBvY2N1cmVuY2VBY2N1bXVsYXRvcisrO1xuICAgICAgICAgICAgICAgIHNsdWcgPSBvcmlnaW5hbFNsdWcgKyAnLScgKyBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0RyeVJ1bikge1xuICAgICAgICAgICAgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z10gPSBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgICAgIHRoaXMuc2VlbltzbHVnXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsdWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgc3RyaW5nIHRvIHVuaXF1ZSBpZFxuICAgICAqL1xuICAgIHNsdWcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0U2FmZVNsdWcoc2x1Zywgb3B0aW9ucy5kcnlydW4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cbmNsYXNzIF9QYXJzZXIge1xuICAgIG9wdGlvbnM7XG4gICAgcmVuZGVyZXI7XG4gICAgdGV4dFJlbmRlcmVyO1xuICAgIHNsdWdnZXI7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGV4cG9ydHMuZGVmYXVsdHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgX1JlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgX1RleHRSZW5kZXJlcigpO1xuICAgICAgICB0aGlzLnNsdWdnZXIgPSBuZXcgX1NsdWdnZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VJbmxpbmUodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICBwYXJzZSh0b2tlbnMsIHRvcCA9IHRydWUpIHtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2dlbmVyaWNUb2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIGdlbmVyaWNUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVsnc3BhY2UnLCAnaHInLCAnaGVhZGluZycsICdjb2RlJywgJ3RhYmxlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdodG1sJywgJ3BhcmFncmFwaCcsICd0ZXh0J10uaW5jbHVkZXMoZ2VuZXJpY1Rva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHInOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKGhlYWRpbmdUb2tlbi50b2tlbnMpLCBoZWFkaW5nVG9rZW4uZGVwdGgsIHVuZXNjYXBlKHRoaXMucGFyc2VJbmxpbmUoaGVhZGluZ1Rva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSwgdGhpcy5zbHVnZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKGNvZGVUb2tlbi50ZXh0LCBjb2RlVG9rZW4ubGFuZywgISFjb2RlVG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGVhZGVyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhYmxlVG9rZW4uaGVhZGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUodGFibGVUb2tlbi5oZWFkZXJbal0udG9rZW5zKSwgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0YWJsZVRva2VuLmFsaWduW2pdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm9keSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhYmxlVG9rZW4ucm93cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGFibGVUb2tlbi5yb3dzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUocm93W2tdLnRva2VucyksIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRhYmxlVG9rZW4uYWxpZ25ba10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrcXVvdGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5wYXJzZShibG9ja3F1b3RlVG9rZW4udG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkID0gbGlzdFRva2VuLm9yZGVyZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbGlzdFRva2VuLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29zZSA9IGxpc3RUb2tlbi5sb29zZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaXN0VG9rZW4uaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0VG9rZW4uaXRlbXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gaXRlbS5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IGl0ZW0udGFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtQm9keSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveCghIWNoZWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vuc1swXS50b2tlbnMgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgISFjaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKGh0bWxUb2tlbi50ZXh0LCBodG1sVG9rZW4uYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZUlubGluZShwYXJhZ3JhcGhUb2tlbi50b2tlbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSB0ZXh0VG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0ZXh0VG9rZW4udG9rZW5zKSA6IHRleHRUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSArIDEgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VG9rZW4gPSB0b2tlbnNbKytpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gJ1xcbicgKyAodGV4dFRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodGV4dFRva2VuLnRva2VucykgOiB0ZXh0VG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIElubGluZSBUb2tlbnNcbiAgICAgKi9cbiAgICBwYXJzZUlubGluZSh0b2tlbnMsIHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXNjYXBlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dChlc2NhcGVUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5odG1sKHRhZ1Rva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluayc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKGxpbmtUb2tlbi5ocmVmLCBsaW5rVG9rZW4udGl0bGUsIHRoaXMucGFyc2VJbmxpbmUobGlua1Rva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZShpbWFnZVRva2VuLmhyZWYsIGltYWdlVG9rZW4udGl0bGUsIGltYWdlVG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdzdHJvbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9uZ1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5zdHJvbmcodGhpcy5wYXJzZUlubGluZShzdHJvbmdUb2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdlbSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW1Ub2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZW0odGhpcy5wYXJzZUlubGluZShlbVRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGVzcGFuJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2Rlc3BhblRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbihjb2Rlc3BhblRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYnInOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5icigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZGVsKHRoaXMucGFyc2VJbmxpbmUoZGVsVG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRleHRUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuXG5jbGFzcyBfSG9va3Mge1xuICAgIG9wdGlvbnM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGV4cG9ydHMuZGVmYXVsdHM7XG4gICAgfVxuICAgIHN0YXRpYyBwYXNzVGhyb3VnaEhvb2tzID0gbmV3IFNldChbXG4gICAgICAgICdwcmVwcm9jZXNzJyxcbiAgICAgICAgJ3Bvc3Rwcm9jZXNzJ1xuICAgIF0pO1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgbWFya2Rvd24gYmVmb3JlIG1hcmtlZFxuICAgICAqL1xuICAgIHByZXByb2Nlc3MobWFya2Rvd24pIHtcbiAgICAgICAgcmV0dXJuIG1hcmtkb3duO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIEhUTUwgYWZ0ZXIgbWFya2VkIGlzIGZpbmlzaGVkXG4gICAgICovXG4gICAgcG9zdHByb2Nlc3MoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG59XG5cbmNsYXNzIE1hcmtlZCB7XG4gICAgZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbiAgICBvcHRpb25zID0gdGhpcy5zZXRPcHRpb25zO1xuICAgIHBhcnNlID0gdGhpcy4jcGFyc2VNYXJrZG93bihfTGV4ZXIubGV4LCBfUGFyc2VyLnBhcnNlKTtcbiAgICBwYXJzZUlubGluZSA9IHRoaXMuI3BhcnNlTWFya2Rvd24oX0xleGVyLmxleElubGluZSwgX1BhcnNlci5wYXJzZUlubGluZSk7XG4gICAgUGFyc2VyID0gX1BhcnNlcjtcbiAgICBwYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xuICAgIFJlbmRlcmVyID0gX1JlbmRlcmVyO1xuICAgIFRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG4gICAgTGV4ZXIgPSBfTGV4ZXI7XG4gICAgbGV4ZXIgPSBfTGV4ZXIubGV4O1xuICAgIFRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG4gICAgU2x1Z2dlciA9IF9TbHVnZ2VyO1xuICAgIEhvb2tzID0gX0hvb2tzO1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy51c2UoLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAgICAgKi9cbiAgICB3YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChjYWxsYmFjay5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGFibGVUb2tlbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlVG9rZW4ucm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMobGlzdFRva2VuLml0ZW1zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucz8uY2hpbGRUb2tlbnM/LltnZW5lcmljVG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tnZW5lcmljVG9rZW4udHlwZV0uZm9yRWFjaCgoY2hpbGRUb2tlbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhnZW5lcmljVG9rZW5bY2hpbGRUb2tlbnNdLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZ2VuZXJpY1Rva2VuLnRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoZ2VuZXJpY1Rva2VuLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICB1c2UoLi4uYXJncykge1xuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zIHx8IHsgcmVuZGVyZXJzOiB7fSwgY2hpbGRUb2tlbnM6IHt9IH07XG4gICAgICAgIGFyZ3MuZm9yRWFjaCgocGFjaykgPT4ge1xuICAgICAgICAgICAgLy8gY29weSBvcHRpb25zIHRvIG5ldyBvYmplY3RcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7IC4uLnBhY2sgfTtcbiAgICAgICAgICAgIC8vIHNldCBhc3luYyB0byB0cnVlIGlmIGl0IHdhcyBzZXQgdG8gdHJ1ZSBiZWZvcmVcbiAgICAgICAgICAgIG9wdHMuYXN5bmMgPSB0aGlzLmRlZmF1bHRzLmFzeW5jIHx8IG9wdHMuYXN5bmMgfHwgZmFsc2U7XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFwiYWRkb25cIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBwYWNrLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5zaW9uIG5hbWUgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3JlbmRlcmVyJyBpbiBleHQpIHsgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgZXh0ZW5zaW9uIHdpdGggZnVuYyB0byBydW4gbmV3IGV4dGVuc2lvbiBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBleHQucmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0b2tlbml6ZXInIGluIGV4dCkgeyAvLyBUb2tlbml6ZXIgRXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgKGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRMZXZlbCA9IGV4dGVuc2lvbnNbZXh0LmxldmVsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dExldmVsLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0gPSBbZXh0LnRva2VuaXplcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0LnN0YXJ0KSB7IC8vIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciBzdGFydCBvZiB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jayA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4dC5sZXZlbCA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgnY2hpbGRUb2tlbnMnIGluIGV4dCAmJiBleHQuY2hpbGRUb2tlbnMpIHsgLy8gQ2hpbGQgdG9rZW5zIHRvIGJlIHZpc2l0ZWQgYnkgd2Fsa1Rva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tleHQubmFtZV0gPSBleHQuY2hpbGRUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcHRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBcIm92ZXJ3cml0ZVwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZGVmYXVsdHMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcih0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlckZ1bmMgPSBwYWNrLnJlbmRlcmVyW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlcktleSA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3JlbmRlcmVyS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcltyZW5kZXJlcktleV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IHJlbmRlcmVyRnVuYy5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXIgPSB0aGlzLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgX1Rva2VuaXplcih0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyRnVuYyA9IHBhY2sudG9rZW5pemVyW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXJLZXkgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2VG9rZW5pemVyID0gdG9rZW5pemVyW3Rva2VuaXplcktleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdG9rZW5pemVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRva2VuaXplclt0b2tlbml6ZXJLZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSB0b2tlbml6ZXJGdW5jLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZUb2tlbml6ZXIuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBIb29rcyBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLmRlZmF1bHRzLmhvb2tzIHx8IG5ldyBfSG9va3MoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob29rc0Z1bmMgPSBwYWNrLmhvb2tzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob29rc0tleSA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZIb29rID0gaG9va3NbaG9va3NLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX0hvb2tzLnBhc3NUaHJvdWdoSG9va3MuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rc1tob29rc0tleV0gPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob29rc0Z1bmMuY2FsbChob29rcywgYXJnKSkudGhlbihyZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZIb29rLmNhbGwoaG9va3MsIHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBob29rc0Z1bmMuY2FsbChob29rcywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rc1tob29rc0tleV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBob29rc0Z1bmMuYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZIb29rLmFwcGx5KGhvb2tzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5ob29rcyA9IGhvb2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2sud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGtUb2tlbnMgPSB0aGlzLmRlZmF1bHRzLndhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja1dhbGt0b2tlbnMgPSBwYWNrLndhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3B0cy53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFja1dhbGt0b2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh3YWxrVG9rZW5zLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHRzIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHQpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3B0IH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAjcGFyc2VNYXJrZG93bihsZXhlciwgcGFyc2VyKSB7XG4gICAgICAgIHJldHVybiAoc3JjLCBvcHRPckNhbGxiYWNrLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRPckNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIG9wdE9yQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3JpZ09wdCA9IHsgLi4ub3B0T3JDYWxsYmFjayB9O1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcmlnT3B0IH07XG4gICAgICAgICAgICAvLyBTaG93IHdhcm5pbmcgaWYgYW4gZXh0ZW5zaW9uIHNldCBhc3luYyB0byB0cnVlIGJ1dCB0aGUgcGFyc2Ugd2FzIGNhbGxlZCB3aXRoIGFzeW5jOiBmYWxzZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMgPT09IHRydWUgJiYgb3JpZ09wdC5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdC5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogVGhlIGFzeW5jIG9wdGlvbiB3YXMgc2V0IHRvIHRydWUgYnkgYW4gZXh0ZW5zaW9uLiBUaGUgYXN5bmM6IGZhbHNlIG9wdGlvbiBzZW50IHRvIHBhcnNlIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRocm93RXJyb3IgPSB0aGlzLiNvbkVycm9yKCEhb3B0LnNpbGVudCwgISFvcHQuYXN5bmMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICd1bmRlZmluZWQnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICdcbiAgICAgICAgICAgICAgICAgICAgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrRGVwcmVjYXRpb25zKG9wdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgIG9wdC5ob29rcy5vcHRpb25zID0gb3B0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbnM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBsZXhlcihzcmMsIG9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkb25lID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0LndhbGtUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKG91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhyb3dFcnJvcihlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlc3VsdENhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2Vucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsICh0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgKGVyciwgY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwgJiYgY29kZSAhPT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHQuaG9va3MgPyBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpIDogc3JjKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihzcmMgPT4gbGV4ZXIoc3JjLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gb3B0LndhbGtUb2tlbnMgPyBQcm9taXNlLmFsbCh0aGlzLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2VucykpLnRoZW4oKCkgPT4gdG9rZW5zKSA6IHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IHBhcnNlcih0b2tlbnMsIG9wdCkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGh0bWwgPT4gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKGh0bWwpIDogaHRtbClcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHRocm93RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IGxleGVyKHNyYywgb3B0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LndhbGtUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IHBhcnNlcih0b2tlbnMsIG9wdCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBodG1sID0gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKGh0bWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgICNvbkVycm9yKHNpbGVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nXG4gICAgICAgICAgICAgICAgICAgICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICArICc8L3ByZT4nO1xuICAgICAgICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuY29uc3QgbWFya2VkSW5zdGFuY2UgPSBuZXcgTWFya2VkKCk7XG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLnBhcnNlKHNyYywgb3B0LCBjYWxsYmFjayk7XG59XG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBIYXNoIG9mIG9wdGlvbnNcbiAqL1xubWFya2VkLm9wdGlvbnMgPVxuICAgIG1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgbWFya2VkSW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgICAgIHJldHVybiBtYXJrZWQ7XG4gICAgfTtcbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luYWwgbWFya2VkIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xubWFya2VkLmdldERlZmF1bHRzID0gX2dldERlZmF1bHRzO1xubWFya2VkLmRlZmF1bHRzID0gZXhwb3J0cy5kZWZhdWx0cztcbi8qKlxuICogVXNlIEV4dGVuc2lvblxuICovXG5tYXJrZWQudXNlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBtYXJrZWRJbnN0YW5jZS51c2UoLi4uYXJncyk7XG4gICAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICByZXR1cm4gbWFya2VkO1xufTtcbi8qKlxuICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICovXG5tYXJrZWQud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLndhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBDb21waWxlcyBtYXJrZG93biB0byBIVE1MIHdpdGhvdXQgZW5jbG9zaW5nIGBwYCB0YWcuXG4gKlxuICogQHBhcmFtIHNyYyBTdHJpbmcgb2YgbWFya2Rvd24gc291cmNlIHRvIGJlIGNvbXBpbGVkXG4gKiBAcGFyYW0gb3B0aW9ucyBIYXNoIG9mIG9wdGlvbnNcbiAqIEByZXR1cm4gU3RyaW5nIG9mIGNvbXBpbGVkIEhUTUxcbiAqL1xubWFya2VkLnBhcnNlSW5saW5lID0gbWFya2VkSW5zdGFuY2UucGFyc2VJbmxpbmU7XG4vKipcbiAqIEV4cG9zZVxuICovXG5tYXJrZWQuUGFyc2VyID0gX1BhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gX1JlbmRlcmVyO1xubWFya2VkLlRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG5tYXJrZWQuTGV4ZXIgPSBfTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBfTGV4ZXIubGV4O1xubWFya2VkLlRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG5tYXJrZWQuU2x1Z2dlciA9IF9TbHVnZ2VyO1xubWFya2VkLkhvb2tzID0gX0hvb2tzO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xuY29uc3Qgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xuY29uc3Qgc2V0T3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zO1xuY29uc3QgdXNlID0gbWFya2VkLnVzZTtcbmNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbmNvbnN0IHBhcnNlSW5saW5lID0gbWFya2VkLnBhcnNlSW5saW5lO1xuY29uc3QgcGFyc2UgPSBtYXJrZWQ7XG5jb25zdCBwYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xuY29uc3QgbGV4ZXIgPSBfTGV4ZXIubGV4O1xuXG5leHBvcnRzLkhvb2tzID0gX0hvb2tzO1xuZXhwb3J0cy5MZXhlciA9IF9MZXhlcjtcbmV4cG9ydHMuTWFya2VkID0gTWFya2VkO1xuZXhwb3J0cy5QYXJzZXIgPSBfUGFyc2VyO1xuZXhwb3J0cy5SZW5kZXJlciA9IF9SZW5kZXJlcjtcbmV4cG9ydHMuU2x1Z2dlciA9IF9TbHVnZ2VyO1xuZXhwb3J0cy5UZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xuZXhwb3J0cy5Ub2tlbml6ZXIgPSBfVG9rZW5pemVyO1xuZXhwb3J0cy5nZXREZWZhdWx0cyA9IF9nZXREZWZhdWx0cztcbmV4cG9ydHMubGV4ZXIgPSBsZXhlcjtcbmV4cG9ydHMubWFya2VkID0gbWFya2VkO1xuZXhwb3J0cy5vcHRpb25zID0gb3B0aW9ucztcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucGFyc2VJbmxpbmUgPSBwYXJzZUlubGluZTtcbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xuZXhwb3J0cy5zZXRPcHRpb25zID0gc2V0T3B0aW9ucztcbmV4cG9ydHMudXNlID0gdXNlO1xuZXhwb3J0cy53YWxrVG9rZW5zID0gd2Fsa1Rva2Vucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcmtlZC5janMubWFwXG4iXSwibmFtZXMiOlsiX2dldERlZmF1bHRzIiwiYXN5bmMiLCJiYXNlVXJsIiwiYnJlYWtzIiwiZXh0ZW5zaW9ucyIsImdmbSIsImhlYWRlcklkcyIsImhlYWRlclByZWZpeCIsImhpZ2hsaWdodCIsImhvb2tzIiwibGFuZ1ByZWZpeCIsIm1hbmdsZSIsInBlZGFudGljIiwicmVuZGVyZXIiLCJzYW5pdGl6ZSIsInNhbml0aXplciIsInNpbGVudCIsInNtYXJ0eXBhbnRzIiwidG9rZW5pemVyIiwid2Fsa1Rva2VucyIsInhodG1sIiwiZXhwb3J0cyIsImRlZmF1bHRzIiwiY2hhbmdlRGVmYXVsdHMiLCJuZXdEZWZhdWx0cyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiUmVnRXhwIiwic291cmNlIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZW1lbnRzIiwiZ2V0RXNjYXBlUmVwbGFjZW1lbnQiLCJjaCIsImVzY2FwZSIsImh0bWwiLCJlbmNvZGUiLCJ0ZXN0IiwicmVwbGFjZSIsInVuZXNjYXBlVGVzdCIsInVuZXNjYXBlIiwiXyIsIm4iLCJ0b0xvd2VyQ2FzZSIsImNoYXJBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiY2FyZXQiLCJlZGl0IiwicmVnZXgiLCJvcHQiLCJvYmoiLCJuYW1lIiwidmFsIiwiZ2V0UmVnZXgiLCJub25Xb3JkQW5kQ29sb25UZXN0Iiwib3JpZ2luSW5kZXBlbmRlbnRVcmwiLCJjbGVhblVybCIsImJhc2UiLCJocmVmIiwicHJvdCIsImRlY29kZVVSSUNvbXBvbmVudCIsImUiLCJpbmRleE9mIiwicmVzb2x2ZVVybCIsImVuY29kZVVSSSIsImJhc2VVcmxzIiwianVzdERvbWFpbiIsInByb3RvY29sIiwiZG9tYWluIiwicnRyaW0iLCJyZWxhdGl2ZUJhc2UiLCJub29wVGVzdCIsImV4ZWMiLCJzcGxpdENlbGxzIiwidGFibGVSb3ciLCJjb3VudCIsInJvdyIsIm1hdGNoIiwib2Zmc2V0Iiwic3RyIiwiZXNjYXBlZCIsImN1cnIiLCJjZWxscyIsInNwbGl0IiwiaSIsInRyaW0iLCJzaGlmdCIsImxlbmd0aCIsInBvcCIsInNwbGljZSIsInB1c2giLCJjIiwiaW52ZXJ0IiwibCIsInN1ZmZMZW4iLCJjdXJyQ2hhciIsInNsaWNlIiwiZmluZENsb3NpbmdCcmFja2V0IiwiYiIsImxldmVsIiwiY2hlY2tEZXByZWNhdGlvbnMiLCJjYWxsYmFjayIsImNvbnNvbGUiLCJ3YXJuIiwib3V0cHV0TGluayIsImNhcCIsImxpbmsiLCJyYXciLCJsZXhlciIsInRpdGxlIiwidGV4dCIsInN0YXRlIiwiaW5MaW5rIiwidG9rZW4iLCJ0eXBlIiwidG9rZW5zIiwiaW5saW5lVG9rZW5zIiwiaW5kZW50Q29kZUNvbXBlbnNhdGlvbiIsIm1hdGNoSW5kZW50VG9Db2RlIiwiaW5kZW50VG9Db2RlIiwibWFwIiwibm9kZSIsIm1hdGNoSW5kZW50SW5Ob2RlIiwiaW5kZW50SW5Ob2RlIiwiam9pbiIsIl9Ub2tlbml6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJzcGFjZSIsInNyYyIsInJ1bGVzIiwiYmxvY2siLCJuZXdsaW5lIiwiY29kZSIsImNvZGVCbG9ja1N0eWxlIiwiZmVuY2VzIiwibGFuZyIsImlubGluZSIsIl9lc2NhcGVzIiwiaGVhZGluZyIsInRyaW1tZWQiLCJkZXB0aCIsImhyIiwiYmxvY2txdW90ZSIsInRvcCIsImJsb2NrVG9rZW5zIiwibGlzdCIsImJ1bGwiLCJpc29yZGVyZWQiLCJvcmRlcmVkIiwic3RhcnQiLCJsb29zZSIsIml0ZW1zIiwiaXRlbVJlZ2V4IiwiaXRlbUNvbnRlbnRzIiwiZW5kc1dpdGhCbGFua0xpbmUiLCJlbmRFYXJseSIsImxpbmUiLCJ0IiwicmVwZWF0IiwibmV4dExpbmUiLCJpbmRlbnQiLCJ0cmltTGVmdCIsInNlYXJjaCIsImJsYW5rTGluZSIsIm5leHRCdWxsZXRSZWdleCIsIk1hdGgiLCJtaW4iLCJoclJlZ2V4IiwiZmVuY2VzQmVnaW5SZWdleCIsImhlYWRpbmdCZWdpblJlZ2V4IiwicmF3TGluZSIsImlzdGFzayIsImlzY2hlY2tlZCIsInRhc2siLCJjaGVja2VkIiwidHJpbVJpZ2h0Iiwic3BhY2VycyIsImZpbHRlciIsImhhc011bHRpcGxlTGluZUJyZWFrcyIsInNvbWUiLCJwcmUiLCJwYXJhZ3JhcGgiLCJkZWYiLCJ0YWciLCJ0YWJsZSIsIml0ZW0iLCJoZWFkZXIiLCJhbGlnbiIsInJvd3MiLCJqIiwiayIsImxoZWFkaW5nIiwiaW5SYXdCbG9jayIsInRyaW1tZWRVcmwiLCJydHJpbVNsYXNoIiwibGFzdFBhcmVuSW5kZXgiLCJsaW5rTGVuIiwicmVmbGluayIsImxpbmtzIiwibm9saW5rIiwiZW1TdHJvbmciLCJtYXNrZWRTcmMiLCJwcmV2Q2hhciIsImxEZWxpbSIsIm5leHRDaGFyIiwicHVuY3R1YXRpb24iLCJsTGVuZ3RoIiwickRlbGltIiwickxlbmd0aCIsImRlbGltVG90YWwiLCJtaWREZWxpbVRvdGFsIiwiZW5kUmVnIiwickRlbGltQXN0IiwickRlbGltVW5kIiwibGFzdEluZGV4IiwiaW5kZXgiLCJjb2Rlc3BhbiIsImhhc05vblNwYWNlQ2hhcnMiLCJoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyIsImJyIiwiZGVsIiwiYXV0b2xpbmsiLCJ1cmwiLCJwcmV2Q2FwWmVybyIsIl9iYWNrcGVkYWwiLCJpbmxpbmVUZXh0IiwiX3BhcmFncmFwaCIsIl9sYWJlbCIsIl90aXRsZSIsImJ1bGxldCIsImxpc3RJdGVtU3RhcnQiLCJfdGFnIiwiX2NvbW1lbnQiLCJub3JtYWwiLCJyZWZsaW5rU2VhcmNoIiwiX3B1bmN0dWF0aW9uIiwiYmxvY2tTa2lwIiwiYW55UHVuY3R1YXRpb24iLCJfc2NoZW1lIiwiX2VtYWlsIiwiX2F0dHJpYnV0ZSIsIl9ocmVmIiwic3Ryb25nIiwibWlkZGxlIiwiZW5kQXN0IiwiZW5kVW5kIiwiZW0iLCJfZXh0ZW5kZWRfZW1haWwiLCJvdXQiLCJyYW5kb20iLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJfTGV4ZXIiLCJPYmplY3QiLCJjcmVhdGUiLCJpbmxpbmVRdWV1ZSIsImxleCIsImxleElubGluZSIsIm5leHQiLCJsZWFkaW5nIiwidGFicyIsImxhc3RUb2tlbiIsImN1dFNyYyIsImxhc3RQYXJhZ3JhcGhDbGlwcGVkIiwiZXh0VG9rZW5pemVyIiwiY2FsbCIsInN0YXJ0QmxvY2siLCJzdGFydEluZGV4IiwiSW5maW5pdHkiLCJ0ZW1wU3JjIiwidGVtcFN0YXJ0IiwiZm9yRWFjaCIsImdldFN0YXJ0SW5kZXgiLCJlcnJNc2ciLCJlcnJvciIsIkVycm9yIiwia2VlcFByZXZDaGFyIiwia2V5cyIsImluY2x1ZGVzIiwibGFzdEluZGV4T2YiLCJzdGFydElubGluZSIsIl9SZW5kZXJlciIsImluZm9zdHJpbmciLCJxdW90ZSIsInNsdWdnZXIiLCJpZCIsInNsdWciLCJib2R5Iiwic3RhcnRhdHQiLCJsaXN0aXRlbSIsImNoZWNrYm94IiwidGFibGVyb3ciLCJjb250ZW50IiwidGFibGVjZWxsIiwiZmxhZ3MiLCJjbGVhbkhyZWYiLCJpbWFnZSIsIl9UZXh0UmVuZGVyZXIiLCJfU2x1Z2dlciIsInNlZW4iLCJzZXJpYWxpemUiLCJ2YWx1ZSIsImdldE5leHRTYWZlU2x1ZyIsIm9yaWdpbmFsU2x1ZyIsImlzRHJ5UnVuIiwib2NjdXJlbmNlQWNjdW11bGF0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsImRyeXJ1biIsIl9QYXJzZXIiLCJ0ZXh0UmVuZGVyZXIiLCJwYXJzZSIsInBhcnNlciIsInBhcnNlSW5saW5lIiwicmVuZGVyZXJzIiwiZ2VuZXJpY1Rva2VuIiwicmV0IiwiaGVhZGluZ1Rva2VuIiwiY29kZVRva2VuIiwidGFibGVUb2tlbiIsImNlbGwiLCJibG9ja3F1b3RlVG9rZW4iLCJsaXN0VG9rZW4iLCJpdGVtQm9keSIsInVuc2hpZnQiLCJodG1sVG9rZW4iLCJwYXJhZ3JhcGhUb2tlbiIsInRleHRUb2tlbiIsImVzY2FwZVRva2VuIiwidGFnVG9rZW4iLCJsaW5rVG9rZW4iLCJpbWFnZVRva2VuIiwic3Ryb25nVG9rZW4iLCJlbVRva2VuIiwiY29kZXNwYW5Ub2tlbiIsImRlbFRva2VuIiwiX0hvb2tzIiwicGFzc1Rocm91Z2hIb29rcyIsIlNldCIsInByZXByb2Nlc3MiLCJtYXJrZG93biIsInBvc3Rwcm9jZXNzIiwiTWFya2VkIiwiYXJncyIsInNldE9wdGlvbnMiLCJwYXJzZU1hcmtkb3duIiwiUGFyc2VyIiwiUmVuZGVyZXIiLCJUZXh0UmVuZGVyZXIiLCJMZXhlciIsIlRva2VuaXplciIsIlNsdWdnZXIiLCJIb29rcyIsInVzZSIsInZhbHVlcyIsImNvbmNhdCIsImNoaWxkVG9rZW5zIiwicGFjayIsIm9wdHMiLCJleHQiLCJwcmV2UmVuZGVyZXIiLCJhcHBseSIsImV4dExldmVsIiwicHJvcCIsInJlbmRlcmVyRnVuYyIsInJlbmRlcmVyS2V5IiwidG9rZW5pemVyRnVuYyIsInRva2VuaXplcktleSIsInByZXZUb2tlbml6ZXIiLCJob29rc0Z1bmMiLCJob29rc0tleSIsInByZXZIb29rIiwiaGFzIiwiYXJnIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicGFja1dhbGt0b2tlbnMiLCJvcHRPckNhbGxiYWNrIiwib3JpZ09wdCIsInRocm93RXJyb3IiLCJvbkVycm9yIiwicHJvdG90eXBlIiwicmVzdWx0Q2FsbGJhY2siLCJkb25lIiwiZXJyIiwicGVuZGluZyIsInNldFRpbWVvdXQiLCJhbGwiLCJjYXRjaCIsIm1lc3NhZ2UiLCJtc2ciLCJyZWplY3QiLCJtYXJrZWRJbnN0YW5jZSIsIm1hcmtlZCIsImdldERlZmF1bHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/marked/lib/marked.cjs\n");

/***/ })

};
;